diff -Naur mythtv-0.18-old/configure mythtv-0.18-new/configure
--- mythtv-0.18-old/configure	2005-04-13 13:35:55.000000000 -0700
+++ mythtv-0.18-new/configure	2005-05-14 06:54:35.218659198 -0700
@@ -3,10 +3,12 @@
 # ffmpeg configure script (c) 2000, 2001, 2002 Fabrice Bellard
 #
 
-x86_mmx_cpus="pentium-mmx,i686,pentium2,pentium3,pentium3m"
-x86_mmx_cpus="$x86_mmx_cpus,i686,pentium-m,pentium4,pentium4m,prescott,athlon,athlon-xp"
-x86_cpus="i386,i486,i586,pentium,pentiumpro,${x86_mmx_cpus}"
-x86_cmov_cpus="pentium-m,pentium4,pentium4m,prescott,athlon,athlon-xp,pentiumpro,i686,c3-2"
+x86_mmx_cpus="pentium-mmx,pentium2,pentium3,pentium3m,pentium-m"
+x86_mmx_cpus="$x86_mmx_cpus,pentium4,pentium4m,prescott,athlon,athlon-xp"
+x86_mmx_cpus="$x86_mmx_cpus,c3,c3-2"
+x86_cpus="i386,i486,i586,i686,pentium,pentiumpro,${x86_mmx_cpus}"
+x86_cmov_cpus="i686,pentiumpro,pentium2,pentium3,pentium3m,pentium-m,pentium4,"
+x86_cmov_cpus="pentium4m,prescott,athlon,athlon-xp,c3-2"
 
 # default parameters
 compile_type="release"
@@ -675,6 +677,30 @@
   esac
 done
 
+has_library()
+{
+    LIBPATHS=`cat /etc/ld.so.conf | grep -v "#" | grep -v "include"`
+    LIBPATHS="$LIBPATHS `echo $LD_LIBRARY_PATH | sed s/':'/' '/g` "
+
+    # recurse down just one level, should be enough in most cases
+    INCL=`cat /etc/ld.so.conf | grep -v "#" | grep "include "`
+    SRCH=`echo $INCL | sed s/"include "//g`
+    for x in $SRCH ; do
+        LP_APPEND=`cat /etc/$x | grep -v "#" | grep -v "include"`
+        LIBPATHS="$LIBPATHS $LP_APPEND"
+    done
+
+    LIBPATHS="`echo $LIBPATHS /lib /usr/lib | sed s/'\/ '/' '/g` "
+
+    HAS_IT="no"
+    for LIBPATH in $LIBPATHS ; do
+        if test x`ls $LIBPATH/$1* 2> /dev/null | head -n 1` != x"" ; then
+            HAS_IT="yes"
+        fi
+    done
+    expr $HAS_IT : "yes" > /dev/null
+}
+
 CCONFIG="$CCONFIG $compile_type"
 if test x$compile_type = x"profile" ; then
     PROFILEFLAGS="-g -DNDEBUG"
@@ -945,6 +971,12 @@
    elif expr "$processor" : ".*Mendocino" > /dev/null ; then
        ARCHFLAGS="-march=pentium2"
        optimize="small"
+   elif expr "$processor" : ".*Klamath" > /dev/null ; then
+       ARCHFLAGS="-march=pentium2"
+       optimize="small"
+   elif expr "$processor" : ".*Deschutes" > /dev/null ; then
+       ARCHFLAGS="-march=pentium2"
+       optimize="small"
 # Athlon 64
    elif expr "$processor" : ".*AMD Athlon(tm) 64" > /dev/null ; then
        ARCHFLAGS="-march=k8"
@@ -958,14 +990,13 @@
 # Athlon
    elif expr "$processor" : "athlon" > /dev/null ; then
        ARCHFLAGS="-march=athlon"
-   elif expr "$processor" : ".*AMD Athlon(tm)" > /dev/null ; then
-       ARCHFLAGS="-march=athlon"
-   elif expr "$processor" : ".*AMD Athlon(TM)" > /dev/null ; then
+   elif expr "$processor" : ".*AMD Athlon(..)" > /dev/null ; then
        ARCHFLAGS="-march=athlon"
-   elif expr "$processor" : ".*AMD Duron(TM)" > /dev/null ; then
+   elif expr "$processor" : ".*AMD Duron(..)" > /dev/null ; then
        ARCHFLAGS="-march=athlon"
        optimize="small"
-   elif expr "$processor" : ".*AMD-K6(tm) 3D processor" > /dev/null ; then
+# K6
+   elif expr "$processor" : ".*AMD-K6(tm) 3D" > /dev/null ; then
        ARCHFLAGS="-march=pentium-mmx"
        optimize="small"
 # Transmeta Crusoe
@@ -981,7 +1012,7 @@
        ARCHFLAGS="-march=c3"
        optimize="small"
        cpu_raw="c3"
-   elif expr "$processor" : ".*VIA Samuel 2" > /dev/null ; then
+   elif expr "$processor" : ".*VIA Samuel" > /dev/null ; then
        ARCHFLAGS="-march=c3"
        optimize="small"
        cpu_raw="c3"
@@ -1606,12 +1637,10 @@
 
 #test for lirc client libraries
 if test x"$lirc" = x"yes" ; then
-   lirc="no"
-   lirc_c1=`ls /usr/lib/liblirc_client.so* 2> /dev/null | head -n 1`
-   lirc_c2=`ls /usr/local/lib/liblirc_client.so* 2> /dev/null | head -n 1`
-   if test x"$lirc_c1" != x"" -o x"$lirc_c2" != x"" ; then
-       lirc="yes"
-   fi
+    lirc="no"
+    if has_library liblirc_client.so ; then
+        lirc="yes"
+    fi
 fi
 
 #test for lirc client header
@@ -1630,16 +1659,8 @@
 
 if test x"$firewire_cable_box" = x"yes" ; then
     firewire_cable_box="no"
-    libiec1=`ls /usr/local/lib/libiec61883* 2> /dev/null | head -n 1`
-    libiec2=`ls /usr/lib/libiec61883* 2> /dev/null | head -n 1`
-    libiec3=`ls /usr/lib64/libiec61883* 2> /dev/null | head -n 1`
-    if test x"$libiec1" != x"" -o x"$libiec2" != x"" -o x"$libiec3" != x"" ; then
-        libraw1=`ls /usr/local/lib/libraw1394* 2> /dev/null | head -n 1`
-        libraw2=`ls /usr/lib/libraw1394* 2> /dev/null | head -n 1`
-        libraw3=`ls /usr/lib64/libraw1394* 2> /dev/null | head -n 1`
-        if test x"$libraw1" != x"" -o x"$libraw2" != x"" -o x"$libraw3" != x"" ; then
+    if has_library libiec61883 -a has_library libavc1394 ; then
             firewire_cable_box="yes"
-        fi
     fi
 fi
 
@@ -1665,7 +1686,7 @@
 
 if test x"$xv" = x"yes" ; then
     xv="no"
-    if test x`ls /usr/X11R6/lib/libXv.* 2> /dev/null | head -n 1` != x"" ; then
+    if has_library libXv ; then
         xv="yes"
     fi
 fi
@@ -1673,24 +1694,25 @@
 VENDOR_XVMC_LIBS=""
 if test x"$xvmc" = x"yes"; then
     xvmc="no"
-    nvidia_xvmc=`ls /usr/X11R6/lib/libXvMCNVIDIA* 2> /dev/null | head -n 1`
-    if test x`ls /usr/X11R6/lib/libXvMCW.* 2> /dev/null | head -n 1` != x"" ; then
+    if has_library libXvMCW ; then
         VENDOR_XVMC_LIBS="-lXvMCW"
         xvmc="yes"
-    elif test x"$nvidia_xvmc" != x""; then
+    elif has_library libXvMCNVIDIA ; then
         VENDOR_XVMC_LIBS="-lXvMCNVIDIA"
         xvmc="yes"
-    elif test x`ls /usr/X11R6/lib/libI810XvMC.* 2> /dev/null | head -n 1` != x"" ; then
+    elif has_library libI810XvMC ; then
         VENDOR_XVMC_LIBS="-lI810XvMC"
         xvmc="yes"
     fi
 fi
 
-if test x`ls /usr/X11R6/lib/libviaXvMC.* 2> /dev/null | head -n 1` = x"" ; then
+if has_library libviaXvMC ; then
+    echo > /dev/null
+else
     xvmc_vld="no"
 fi
 if test x"$xvmc_vld" = x"yes" ; then
-    if test x`ls /usr/X11R6/lib/libXvMCW.* 2> /dev/null | head -n 1` != x"" ; then
+    if has_library libXvMCW ; then
         VENDOR_XVMC_LIBS="-lXvMCW"
     else
         VENDOR_XVMC_LIBS="-lviaXvMC"
@@ -1698,6 +1720,10 @@
     xvmc="yes"
 fi
 
+if test x"$VENDOR_XVMC_LIBS" = x"-lXvMCW" ; then
+    CCONFIG="$CCONFIG using_xvmcw"
+fi
+
 if test x"$opengl_vsync" = x"yes" ; then
     CONFIG_OPENGL_VSYNC_LIBS="-lGL -lGLU"
 fi
@@ -1798,8 +1824,8 @@
 echo "XvMC support     $xvmc"
 echo "XvMC VLD support $xvmc_vld"
 echo "OpenGL vsync     $opengl_vsync"
-if test x"$mingw32" = x"yes" -o x"$cygwin" = x"yes" ; then
 echo "DirectFB         $direct_fb"
+if test x"$mingw32" = x"yes" -o x"$cygwin" = x"yes" ; then
 echo "DirectX          $direct_x"
 fi
 echo
@@ -2255,6 +2281,9 @@
 
 if test x"$mmx" = x"yes"; then
   CONFIG_DEFINES="$CONFIG_DEFINES MMX"
+  if test x"$cpu" != x"x86_64" ; then
+    CONFIG_DEFINES="$CONFIG_DEFINES i386"
+  fi
 fi
 
 if test x"$ivtv" = x"yes" ; then
@@ -2269,7 +2298,7 @@
 if test x"$firewire_cable_box" = x"yes" ; then
   CCONFIG="$CCONFIG using_firewire"
   CONFIG_DEFINES="$CONFIG_DEFINES USING_FIREWIRE"
-  echo "CONFIG_FIREWIRE_LIBS=-lraw1394 -liec61883" >> config.mak
+  echo "CONFIG_FIREWIRE_LIBS=-lraw1394 -liec61883 -lavc1394" >> config.mak
 fi
 
 if test x"$lirc" = x"yes" ; then
@@ -2332,7 +2361,6 @@
 
 if test x"$opengl_vsync" = x"yes" ; then
   CCONFIG="$CCONFIG using_opengl_vsync"
-  CONFIG_DEFINES="$CONFIG_DEFINES USING_OPENGL_VSYNC"
   echo "CONFIG_OPENGL_VSYNC_LIBS=$CONFIG_OPENGL_VSYNC_LIBS" >> config.mak
 fi
 
diff -Naur mythtv-0.18-old/libs/libavcodec/libavcodec.pro mythtv-0.18-new/libs/libavcodec/libavcodec.pro
--- mythtv-0.18-old/libs/libavcodec/libavcodec.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libavcodec/libavcodec.pro	2005-05-14 06:54:35.218659198 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0
+VERSION = 0.18.1
 
 INCLUDEPATH = ../ ../../ 
 
diff -Naur mythtv-0.18-old/libs/libavformat/libavformat.pro mythtv-0.18-new/libs/libavformat/libavformat.pro
--- mythtv-0.18-old/libs/libavformat/libavformat.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libavformat/libavformat.pro	2005-05-14 06:54:35.219659084 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0 
+VERSION = 0.18.1 
 
 INCLUDEPATH += ../ ../../ ../libavcodec ../libmythtv
 
diff -Naur mythtv-0.18-old/libs/libmyth/httpcomms.cpp mythtv-0.18-new/libs/libmyth/httpcomms.cpp
--- mythtv-0.18-old/libs/libmyth/httpcomms.cpp	2004-10-14 20:06:40.000000000 -0700
+++ mythtv-0.18-new/libs/libmyth/httpcomms.cpp	2005-05-14 06:54:35.221658857 -0700
@@ -1,28 +1,33 @@
 #include <iostream>
 #include <qapplication.h>
+#include <qregexp.h>
 #include <unistd.h>
+
+#include "mythcontext.h"
+
 using namespace std;
 
+#include "qmdcodec.h"
 #include "httpcomms.h"
 
-HttpComms::HttpComms(QUrl &url)
+HttpComms::HttpComms()
          : http(0)
 {
-    init(url);
+    init();
 }
 
+
 HttpComms::HttpComms(QUrl &url, int timeoutms)
          : http(0)
 {
-    init(url);
-    m_timer = new QTimer();
-    connect(m_timer, SIGNAL(timeout()), SLOT(timeout()));
-    m_timer->start(timeoutms, TRUE);
+    init();
+    request(url, timeoutms);
 }
 
-HttpComms::HttpComms(QUrl &url, QHttpRequestHeader &header)
+HttpComms::HttpComms(QUrl &url, QHttpRequestHeader &header, int timeoutms)
 {
-    init(url, header);
+    init();
+    request(url, header, timeoutms);
 }
 
 HttpComms::~HttpComms()
@@ -33,7 +38,27 @@
     delete http;
 }
 
-void HttpComms::init(QUrl &url)
+void HttpComms::init()
+{
+ //   m_curRequest = NULL;
+    m_authNeeded = false;
+    http = new QHttp();
+    m_redirectedURL = "";
+    m_done = false;
+    m_statusCode = 0;
+    m_responseReason = "";
+    m_timer = NULL;
+    m_timeout = false;
+    
+
+    connect(http, SIGNAL(done(bool)), this, SLOT(done(bool)));
+    connect(http, SIGNAL(stateChanged(int)), this, SLOT(stateChanged(int)));
+    connect(http, SIGNAL(responseHeaderReceived(const QHttpResponseHeader &)),
+            this, SLOT(headerReceived(const QHttpResponseHeader &)));
+
+}
+
+void HttpComms::request(QUrl &url, int timeoutms, bool allowGzip)
 {
     QHttpRequestHeader header("GET", url.encodedPathAndQuery());
     QString userAgent = "Mozilla/9.876 (X11; U; Linux 2.2.12-20 i686, en) "
@@ -41,13 +66,17 @@
 
     header.setValue("Host", url.host());
     header.setValue("User-Agent", userAgent);
-
-    init(url, header);
+    
+    if (allowGzip)
+        header.setValue( "Accept-Encoding", "gzip");
+    
+    request(url, header, timeoutms);
 }
 
-void HttpComms::init(QUrl &url, QHttpRequestHeader &header)
+
+
+void HttpComms::request(QUrl &url, QHttpRequestHeader &header, int timeoutms)
 {
-    http = new QHttp();
     Q_UINT16 port = 80;
 
     if (url.hasPort()) 
@@ -55,20 +84,28 @@
     
     http->setHost(url.host(), port);
 
-    m_debug = 0;
-    m_redirectedURL = "";
-    m_done = false;
-    m_statusCode = 0;
-    m_responseReason = "";
-    m_timer = NULL;
-    m_timeout = false;
     m_url = url.toString();
+    m_curRequest = header;
 
-    connect(http, SIGNAL(done(bool)), this, SLOT(done(bool)));
-    connect(http, SIGNAL(stateChanged(int)), this, SLOT(stateChanged(int)));
-    connect(http, SIGNAL(responseHeaderReceived(const QHttpResponseHeader &)),
-            this, SLOT(headerReceived(const QHttpResponseHeader &)));
+    if (m_timer)
+        m_timer->stop();
+    
+    if (timeoutms > 0 )
+    {
+        if (!m_timer)
+        {
+            m_timer = new QTimer();
+            connect(m_timer, SIGNAL(timeout()), SLOT(timeout()));
+        }
+        m_timeoutInterval = timeoutms;
+        m_timer->start(timeoutms, TRUE);
+    }        
 
+    if (m_cookie)    
+    {
+        header.setValue("Cookie", m_cookie);
+    }
+    
     http->request(header);
 }
 
@@ -85,17 +122,24 @@
 {
     if (error)
     {
-       cerr << "HttpComms::done() - NetworkOperation Error on Finish: "
-            << http->errorString() << " (" << error << ": url: " 
-            << m_url.latin1() << endl;
+       VERBOSE(VB_IMPORTANT, QString("HttpComms::done() - NetworkOperation Error on Finish: "
+                                     "%1 (%2): url: '%3'")
+                                     .arg(http->errorString())
+                                     .arg(error)
+                                     .arg(m_url.toString().latin1()));
+    }
+    else if (m_authNeeded)
+    {
+        VERBOSE(VB_NETWORK, QString("Authentication pending, ignoring done from first request."));
+        return;            
     }
     else if (http->bytesAvailable())
     {
         m_data.resize(http->bytesAvailable());
         m_data = http->readAll();
     }
-    if (m_debug > 1)
-        cerr << "done: " << m_data.size() << " bytes.\n";
+    
+    VERBOSE(VB_NETWORK, QString("done: %1 bytes").arg(m_data.size()));
 
     m_done = true;
 
@@ -105,20 +149,23 @@
 
 void HttpComms::stateChanged(int state)
 {
-    if (m_debug > 1) 
+    QString stateStr;
+    
+    switch (state) 
     {
-        switch (state) 
-        {
-            case QHttp::Unconnected: cerr << "unconnected\n"; break;
-            case QHttp::HostLookup: break;
-            case QHttp::Connecting: cerr << "connecting\n"; break;
-            case QHttp::Sending: cerr << "sending\n"; break;
-            case QHttp::Reading: cerr << "reading\n"; break;
-            case QHttp::Connected: cerr << "connected\n"; break;
-            case QHttp::Closing: cerr << "closing\n"; break;
-            default: cerr << "unknown state: " << state << endl; break;
-        }
+        case QHttp::Unconnected: stateStr = "unconnected"; break;
+        case QHttp::HostLookup: stateStr =  "host lookup"; break;
+        case QHttp::Connecting: stateStr = "connecting"; break;
+        case QHttp::Sending: stateStr = "sending"; break;
+        case QHttp::Reading: stateStr = "reading"; break;
+        case QHttp::Connected: stateStr =  "connected"; break;
+        case QHttp::Closing: stateStr = "closing"; break;
+        default: stateStr =  "unknown state: "; break;
     }
+
+    VERBOSE(VB_NETWORK, QString("HttpComms::stateChanged: %1 (%2)")
+                                .arg(stateStr)
+                                .arg(state));
 }
 
 void HttpComms::headerReceived(const QHttpResponseHeader &resp)
@@ -126,27 +173,88 @@
     m_statusCode = resp.statusCode();
     m_responseReason = resp.reasonPhrase();
 
-    if (m_debug > 1) 
+    QString sidkey = "set-cookie";
+
+    if (resp.hasKey(sidkey))
     {
-        cerr << "Got HTTP response: " << m_statusCode << ":" 
-             << m_responseReason << endl;    
-        cerr << "Keys: " << resp.keys().join(",") << endl;
+        QRegExp rx("PHPSESSID=(.+);");
+        rx.setMinimal(true);
+        rx.setCaseSensitive(false);
+        if (rx.search(resp.value(sidkey)) >= 0)
+        {
+            m_cookie = "PHPSESSID=" + rx.cap(1);
+            VERBOSE(VB_NETWORK, QString("HttpComms found cookie: %1").arg(m_cookie));
+        }
     }
+    
+    
+    VERBOSE(VB_NETWORK, QString("Got HTTP response: %1:%2")
+                        .arg(m_statusCode)
+                        .arg(m_responseReason));    
+    VERBOSE(VB_NETWORK, QString("Keys: %1")
+                        .arg(resp.keys().join(",") ));
+    
 
     if (resp.statusCode() >= 300 && resp.statusCode() <= 400) 
     {
         // redirection
         QString uri = resp.value("LOCATION");
-        if (m_debug > 0)
-            cerr << "Redirection to: " << uri << endl;
+        VERBOSE(VB_NETWORK, QString("Redirection to: '%1'").arg(uri));
        
         m_redirectedURL = resp.value("LOCATION");
+        m_authNeeded = false;
+    }
+    else if ((resp.statusCode() == 401))
+    {
+        // Toggle the sate of our authentication pending flag
+        // if we've gotten this after having tried to authenticate
+        // once then we've failed authentication and turning the pending off will allow us to exit.
+        m_authNeeded = !m_authNeeded;
+        if (m_authNeeded)
+        {
+            QString authHeader(resp.value("www-authenticate"));
+            
+            if (authHeader.startsWith("Digest") )
+            {            
+                if (!createDigestAuth(false, authHeader, &m_curRequest) )
+                {
+                    m_authNeeded = false;
+                    return;   
+                }
+            }
+            else
+            {
+                QCString auth = QCodecs::base64Encode( QCString( m_webCredentials.user +
+                                                       ":" + m_webCredentials.pass ) );
+                m_curRequest.setValue( "Authorization", QString( "Basic " ).append( auth.data() ) ); 
+            } 
+            
+            if (m_timer)
+            {
+                m_timer->stop();
+                m_timer->start(m_timeoutInterval, TRUE);
+            }
+            
+            // Not sure if it's possible to receive a session ID or other cookie
+            // before authenticating or not.
+            if (m_cookie)    
+            {
+                m_curRequest.setValue("Cookie", m_cookie);
+            }
+            
+            http->request(m_curRequest);
+        }
+    }
+    else
+    {
+        m_authNeeded = false;
     }
 }
 
 void HttpComms::timeout() 
 {
-   cerr << "HttpComms::Timeout for url: " << m_url.latin1() << endl;
+   VERBOSE(VB_IMPORTANT, QString("HttpComms::Timeout for url: %1")
+                               .arg(m_url.toString().latin1()));
    m_timeout = true;
    m_done = true;
 }
@@ -155,13 +263,12 @@
 // getHttp - static function for grabbing http data for a url
 //           this is a synchronous function, it will block according to the vars
 QString HttpComms::getHttp(QString& url, int timeoutMS, int maxRetries, 
-                           int maxRedirects)
+                           int maxRedirects, bool allowGzip,  Credentials* webCred)
 {
     int redirectCount = 0;
     int timeoutCount = 0;
     QString res = "";
     HttpComms *httpGrabber = NULL; 
-    int debug = 0;
     QString hostname = "";
 
     while (1) 
@@ -171,12 +278,19 @@
             hostname = qurl.host();  // hold onto original host
         if (!qurl.hasHost())        // can occur on redirects to partial paths
             qurl.setHost(hostname);
-        if (debug > 0)
-            cerr << "getHttp: grabbing: " << qurl.toString() << endl;
+        
+        VERBOSE(VB_NETWORK, QString("getHttp: grabbing: %1").arg(qurl.toString()));
 
         if (httpGrabber != NULL)
             delete httpGrabber; 
-        httpGrabber = new HttpComms(qurl, timeoutMS);
+        
+        httpGrabber = new HttpComms;
+        
+        if (webCred)
+            httpGrabber->setCredentials(*webCred, CRED_WEB);
+            
+        httpGrabber->request(qurl, timeoutMS, allowGzip);            
+       
 
         while (!httpGrabber->isDone())
         {
@@ -187,21 +301,20 @@
         // Handle timeout
         if (httpGrabber->isTimedout())
         {
-            if (debug > 0) 
-                cerr << "timeout for url:" << url.latin1() << endl;
+            VERBOSE(VB_NETWORK, QString("timeout for url: %1").arg(url.latin1()));
            
             // Increment the counter and check were not over the limit
             if (timeoutCount++ >= maxRetries)
             {
-                cerr << "Failed to contact server for url: " << url.latin1()
-                     << endl;
+                VERBOSE(VB_IMPORTANT, QString("Failed to contact server for url: %1").arg(url.latin1()));
                 break;
             }
 
             // Try again
-            if (debug > 0) 
-               cerr << "attempt # " << (timeoutCount+1) << "/" << maxRetries 
-                    << " for url:" << url.latin1() << endl;
+            VERBOSE(VB_NETWORK, QString("Attempt # %1/%2 for url: %3")
+                                        .arg(timeoutCount + 1)
+                                        .arg(maxRetries)
+                                        .arg(url.latin1()));
 
             continue;
         }
@@ -209,10 +322,10 @@
         // Check for redirection
         if (!httpGrabber->getRedirectedURL().isEmpty()) 
         {
-            if (debug > 0) 
-                cerr << "redirection:" 
-                     << httpGrabber->getRedirectedURL().latin1() << " count:" 
-                     << redirectCount << " max:" << maxRedirects << endl;
+            VERBOSE(VB_NETWORK, QString("Redirection: %1, count: %2, max: %3")
+                                .arg(httpGrabber->getRedirectedURL().latin1())
+                                .arg(redirectCount)
+                                .arg(maxRedirects));
             if (redirectCount++ < maxRedirects)
                 url = httpGrabber->getRedirectedURL();
 
@@ -227,26 +340,26 @@
 
     delete httpGrabber;
 
-    if (debug > 1)
-        cerr << "Got " << res.length() << " bytes from url: '" 
-             << url.latin1() << "'" << endl;
-    if (debug > 2)
-        cerr << res;
+    
+    VERBOSE(VB_NETWORK, QString("Got %1 bytes from url: '%2'")
+                                .arg(res.length())
+                                .arg(url.latin1()));
+    VERBOSE(VB_NETWORK, res);
 
     return res;
 }
 
 // getHttpFile - static function for grabbing a file from an http url
 //      this is a synchronous function, it will block according to the vars
-bool HttpComms::getHttpFile(QString& filename, QString& url, int timeoutMS, 
-                            int maxRetries, int maxRedirects)
+bool HttpComms::getHttpFile(const QString& filename, QString& url, int timeoutMS, 
+                            int maxRetries, int maxRedirects, 
+                            bool allowGzip, Credentials* webCred)
 {
     int redirectCount = 0;
     int timeoutCount = 0;
     QByteArray data(0);
     bool res = false;
     HttpComms *httpGrabber = NULL;
-    int debug = 0;
     QString hostname = "";
 
     while (1)
@@ -254,14 +367,22 @@
         QUrl qurl(url);
         if (hostname == "")
             hostname = qurl.host();  // hold onto original host
+        
         if (!qurl.hasHost())        // can occur on redirects to partial paths
             qurl.setHost(hostname);
-        if (debug > 0)
-            cerr << "getHttp: grabbing: " << qurl.toString() << endl;
+        
+        VERBOSE(VB_NETWORK, QString("getHttp: grabbing: '%1'")
+                                    .arg(qurl.toString()));
 
         if (httpGrabber != NULL)
             delete httpGrabber;
-        httpGrabber = new HttpComms(qurl, timeoutMS);
+        
+        httpGrabber = new HttpComms;
+        
+        if (webCred)
+            httpGrabber->setCredentials(*webCred, CRED_WEB);
+            
+        httpGrabber->request(qurl, timeoutMS, allowGzip);            
 
         while (!httpGrabber->isDone())
         {
@@ -272,21 +393,22 @@
         // Handle timeout
         if (httpGrabber->isTimedout())
         {
-            if (debug > 0)
-                cerr << "timeout for url:" << url.latin1() << endl;
+            VERBOSE(VB_NETWORK, QString("Timeout for url: '%1'")
+                                        .arg(url.latin1()));
 
             // Increment the counter and check were not over the limit
             if (timeoutCount++ >= maxRetries)
             {
-                cerr << "Failed to contact server for url: " << url.latin1()
-                     << endl;
+                VERBOSE(VB_IMPORTANT, QString("Failed to contact server for url: '%1'")
+                                              .arg(url.latin1()));
                 break;
             }
 
             // Try again
-            if (debug > 0)
-               cerr << "attempt # " << (timeoutCount+1) << "/" << maxRetries
-                    << " for url:" << url.latin1() << endl;
+            VERBOSE(VB_NETWORK, QString("Attempt # %1/%2 for url: %3")
+                                        .arg(timeoutCount + 1)
+                                        .arg(maxRetries)
+                                        .arg(url.latin1()));
 
             continue;
         }
@@ -294,10 +416,11 @@
         // Check for redirection
         if (!httpGrabber->getRedirectedURL().isEmpty())
         {
-            if (debug > 0)
-                cerr << "redirection:"
-                     << httpGrabber->getRedirectedURL().latin1() << " count:"
-                     << redirectCount << " max:" << maxRedirects << endl;
+            VERBOSE(VB_NETWORK, QString("redirection: '%1', count: %2, max: %3")
+                                        .arg(httpGrabber->getRedirectedURL().latin1())
+                                        .arg(redirectCount)
+                                        .arg(maxRedirects));
+            
             if (redirectCount++ < maxRedirects)
                 url = httpGrabber->getRedirectedURL();
 
@@ -310,8 +433,8 @@
 
         if (data.size() > 0)
         {
-            if (debug > 0)
-                cerr << "getHttpFile: saving to file: " << filename << endl;
+            VERBOSE(VB_NETWORK, QString("getHttpFile: saving to file: '%1'")
+                                        .arg(filename));
 
             QFile file(filename);
             if (file.open( IO_WriteOnly ))
@@ -320,25 +443,291 @@
                 stream.writeRawBytes( (const char*) (data), data.size() );
                 file.close();
                 res = true;
-                if (debug > 0)
-                    cerr << "getHttpFile: File saved OK" << endl;
+                VERBOSE(VB_NETWORK, QString("getHttpFile: File saved OK"));
             }
             else
-                if (debug > 0)
-                    cerr << "getHttpFile: Failed to open file for writing" << endl;
+                VERBOSE(VB_NETWORK, QString("getHttpFile: Failed to open file for writing"));
         }
         else
-           if (debug > 0)
-               cerr << "getHttpFile: nothing to save to file!" << endl;
+           VERBOSE(VB_NETWORK, QString("getHttpFile: nothing to save to file!"));
 
         break;
     }
 
-    if (debug > 1)
-        cerr << "Got " << data.size() << " bytes from url: '"
-             << url.latin1() << "'" << endl;
+    VERBOSE(VB_NETWORK, QString("Got %1 bytes from url: '%2'")
+                                .arg(data.size())
+                                .arg(url.latin1()));
 
     delete httpGrabber;
 
     return res;
 }
+
+
+
+bool HttpComms::createDigestAuth ( bool isForProxy, const QString& authStr, QHttpRequestHeader* request)
+{
+    const char *p;
+    QString header;
+    QString auth;
+    QCString opaque;
+    QCString Response;
+
+    DigestAuthInfo info;
+
+    opaque = "";
+      
+    if ( isForProxy )
+    {
+        header = "Proxy-Authorization";
+        auth = "Digest ";
+        info.username = m_proxyCredentials.user.latin1();
+        info.password = m_proxyCredentials.pass.latin1();
+        p = authStr.latin1();
+    }
+    else
+    {
+        header = "Authorization";
+        auth = "Digest ";
+        info.username = m_webCredentials.user.latin1();
+        info.password = m_webCredentials.pass.latin1();
+        p = authStr.latin1();
+    }
+  
+    if (!p || !*p)
+        return false;
+
+    p += 6; // Skip "Digest"
+
+    if ( info.username.isEmpty() || info.password.isEmpty() || !p )
+        return false;
+
+  
+    info.realm = "";
+    info.algorithm = "MD5";
+    info.nonce = "";
+    info.qop = "";
+
+    // cnonce is recommended to contain about 64 bits of entropy
+    // TODO: Fix this
+    info.cnonce =  "QPDExMTQ";
+  
+    // HACK: Should be fixed according to RFC 2617 section 3.2.2
+    info.nc = "00000001";
+
+    // Set the method used...
+    info.method = request->method();
+  
+    // Parse the Digest response....
+    while (*p)
+    {
+        int i = 0;
+        while ( (*p == ' ') || (*p == ',') || (*p == '\t')) {p++;}
+    
+        if (strncasecmp(p, "realm=", 6 )==0)
+        {
+            p+=6;
+            while ( *p == '"' ) p++;  // Go past any number of " mark(s) first
+            while ( p[i] != '"' ) i++;  // Read everything until the last " mark
+            info.realm = QCString( p, i+1 );
+        }
+        else if (strncasecmp(p, "algorith=", 9)==0)
+        {
+            p+=9;
+            while ( *p == '"' ) p++;  // Go past any number of " mark(s) first
+            while ( ( p[i] != '"' ) && ( p[i] != ',' ) && ( p[i] != '\0' ) ) i++;
+            info.algorithm = QCString(p, i+1);
+        }
+        else if (strncasecmp(p, "algorithm=", 10)==0)
+        {
+            p+=10;
+            while ( *p == '"' ) p++;  // Go past any " mark(s) first
+            while ( ( p[i] != '"' ) && ( p[i] != ',' ) && ( p[i] != '\0' ) ) i++;
+            info.algorithm = QCString(p,i+1);
+        }
+        else if (strncasecmp(p, "domain=", 7)==0)
+        {
+            p+=7;
+            while ( *p == '"' ) p++;  // Go past any " mark(s) first
+            while ( p[i] != '"' ) i++;  // Read everything until the last " mark
+            int pos;
+            int idx = 0;
+            QCString uri = QCString(p,i+1);
+            do
+            {
+                pos = uri.find( ' ', idx );
+     
+                if ( pos != -1 )
+                {
+                    QUrl u (m_url, uri.mid(idx, pos-idx));
+                    if (u.isValid ())
+                        info.digestURI.append( u.toString().latin1() );
+                }
+                else
+                {
+                    QUrl u (m_url, uri.mid(idx, uri.length()-idx));
+                    if (u.isValid ())
+                        info.digestURI.append( u.toString().latin1() );
+                }
+                idx = pos+1;
+            } while ( pos != -1 );
+        }
+        else if (strncasecmp(p, "nonce=", 6)==0)
+        {
+            p+=6;
+            while ( *p == '"' ) p++;  // Go past any " mark(s) first
+            while ( p[i] != '"' ) i++;  // Read everything until the last " mark
+            info.nonce = QCString(p,i+1);
+        }
+        else if (strncasecmp(p, "opaque=", 7)==0)
+        {
+            p+=7;
+            while ( *p == '"' ) p++;  // Go past any " mark(s) first
+            while ( p[i] != '"' ) i++;  // Read everything until the last " mark
+            opaque = QCString(p,i+1);
+        }
+        else if (strncasecmp(p, "qop=", 4)==0)
+        {
+            p+=4;
+            while ( *p == '"' ) p++;  // Go past any " mark(s) first
+            while ( p[i] != '"' ) i++;  // Read everything until the last " mark
+            info.qop = QCString(p,i+1);
+        }
+        p+=(i+1);
+    }
+
+    if (info.realm.isEmpty() || info.nonce.isEmpty())
+        return false;
+  
+    info.digestURI.append (m_url.encodedPathAndQuery());
+  
+    
+//     cerr << " RESULT OF PARSING:" << endl;
+//     cerr << "   algorithm: " << info.algorithm << endl;
+//     cerr << "   realm:     " << info.realm << endl;
+//     cerr << "   nonce:     " << info.nonce << endl;
+//     cerr << "   opaque:    " << opaque << endl;
+//     cerr << "   qop:       " << info.qop << endl;
+    
+    
+    // Calculate the response...
+    calculateDigestResponse( info, Response );
+
+    auth += "username=\"";
+    auth += info.username;
+
+    auth += "\", realm=\"";
+    auth += info.realm;
+    auth += "\"";
+
+    auth += ", nonce=\"";
+    auth += info.nonce;
+
+    auth += "\", uri=\"";
+    auth += m_url.encodedPathAndQuery();
+
+    auth += "\", algorithm=\"";
+    auth += info.algorithm;
+    auth +="\"";
+
+    if ( !info.qop.isEmpty() )
+    {
+        auth += ", qop=\"";
+        auth += info.qop;
+        auth += "\", cnonce=\"";
+        auth += info.cnonce;
+        auth += "\", nc=";
+        auth += info.nc;
+    }
+
+    auth += ", response=\"";
+    auth += Response;
+    if ( !opaque.isEmpty() )
+    {
+        auth += "\", opaque=\"";
+        auth += opaque;
+    }
+  
+    auth += "\"";
+    
+    
+    VERBOSE(VB_NETWORK, QString("Setting auth header %1 to '%2'")
+                                .arg(header).arg(auth));
+
+    
+    if (request)
+        request->setValue(header, auth);
+        
+    return true;
+}
+
+
+void HttpComms::calculateDigestResponse( DigestAuthInfo& info, QCString& Response )
+{
+    QMD5 md;
+    QCString HA1;
+    QCString HA2;
+
+    // Calculate H(A1)
+    QCString authStr = info.username;
+    authStr += ':';
+    authStr += info.realm;
+    authStr += ':';
+    authStr += info.password;
+    md.update( authStr );
+
+    if ( info.algorithm.lower() == "md5-sess" )
+    {
+        authStr = md.hexDigest();
+        authStr += ':';
+        authStr += info.nonce;
+        authStr += ':';
+        authStr += info.cnonce;
+        md.reset();
+        md.update( authStr );
+    }
+    
+    HA1 = md.hexDigest();
+
+    //cerr << " calculateResponse(): A1 => " << HA1 << endl;
+
+    // Calculate H(A2)
+    authStr = info.method;
+    authStr += ':';
+    authStr += m_url.encodedPathAndQuery().latin1();
+    if ( info.qop == "auth-int" )
+    {
+        authStr += ':';
+        authStr += info.entityBody;
+    }
+    
+    md.reset();
+    md.update( authStr );
+    HA2 = md.hexDigest();
+
+    //cerr << " calculateResponse(): A2 => " << HA2 << endl;
+
+    // Calculate the response.
+    authStr = HA1;
+    authStr += ':';
+    authStr += info.nonce;
+    authStr += ':';
+    if ( !info.qop.isEmpty() )
+    {
+        authStr += info.nc;
+        authStr += ':';
+        authStr += info.cnonce;
+        authStr += ':';
+        authStr += info.qop;
+        authStr += ':';
+    }
+  
+    authStr += HA2;
+    md.reset();
+    md.update( authStr );
+    Response = md.hexDigest();
+
+    //cerr << " calculateResponse(): Response => " << Response << endl;
+}
+
+
diff -Naur mythtv-0.18-old/libs/libmyth/httpcomms.h mythtv-0.18-new/libs/libmyth/httpcomms.h
--- mythtv-0.18-old/libs/libmyth/httpcomms.h	2004-08-18 19:52:13.000000000 -0700
+++ mythtv-0.18-new/libs/libmyth/httpcomms.h	2005-05-14 06:54:35.221658857 -0700
@@ -11,10 +11,9 @@
 {
     Q_OBJECT
   public:
-    HttpComms(QUrl &url);
-    HttpComms(QUrl &url, int timeoutms);
-    HttpComms(QUrl &url, QHttpRequestHeader &header);
-
+    HttpComms();
+    HttpComms(QUrl &url, int timeoutms = -1);
+    HttpComms(QUrl &url, QHttpRequestHeader &header, int timeoutms = -1);
     virtual ~HttpComms();
 
     bool isDone(void) { return m_done; }
@@ -31,13 +30,61 @@
 
     bool isTimedout(void) { return m_timeout; }
 
+    class Credentials
+    {
+        public:
+            Credentials( const QString& _user="", const QString& _pass="") { user = _user; pass = _pass; }
+            QString user;
+            QString pass;
+    };                           
+    
+    enum CredentialTypes { CRED_WEB, CRED_PROXY };
+    
+    void setCredentials(const Credentials& cred, int credType)
+    { 
+        if (credType == CRED_PROXY)
+            m_proxyCredentials = cred;
+        else
+            m_webCredentials = cred;
+    }
+    
+    
     static QString getHttp(QString& url, int timeoutMS = 10000, 
-                           int maxRetries = 3, int maxRedirects = 3);
-    static bool getHttpFile(QString& file, QString& url, int timeoutMS = 10000,
-                           int maxRetries = 3, int maxRedirects = 3);
+                           int maxRetries = 3, int maxRedirects = 3,
+                           bool allowGzip = false,
+                           Credentials* webCred = NULL);
+    
+    static bool getHttpFile(const QString& file, QString& url, int timeoutMS = 10000,
+                            int maxRetries = 3, int maxRedirects = 3, 
+                            bool allowGzip = false, Credentials* webCred = NULL);
+    
+    
+    void request(QUrl &url, int timeoutms = -1, bool allowGzip = false);
+    void request(QUrl &url, QHttpRequestHeader &header, int timeoutms = -1);
+    
+    void setCookie( const QString& cookie ) { m_cookie = cookie; }
+    const QString& getCookie() const { return m_cookie; }
+        
   protected:
-    void init(QUrl &url);
-    void init(QUrl &url, QHttpRequestHeader &header);
+    struct DigestAuthInfo
+    {
+        QCString nc;
+        QCString qop;
+        QCString realm;
+        QCString nonce;
+        QCString method;
+        QCString cnonce;
+        QCString username;
+        QCString password;
+        QStrList digestURI;
+        QCString algorithm;
+        QCString entityBody;
+    };
+    
+    void init();
+    
+    void calculateDigestResponse( DigestAuthInfo& info, QCString& Response );
+    bool createDigestAuth( bool isForProxy, const QString& authStr, QHttpRequestHeader* request );
     
   private slots:
     void timeout();
@@ -50,13 +97,19 @@
     int m_statusCode;
     QString m_redirectedURL;
     QString m_responseReason;
+    Credentials m_webCredentials;
+    Credentials m_proxyCredentials;
     QHttp *http;
     bool m_done;
     QByteArray m_data;
-    QString m_url;
+    QUrl m_url;
     QTimer* m_timer;
     bool m_timeout;
-    int  m_debug;
+    bool m_authNeeded;
+    int m_timeoutInterval;
+    QString m_cookie;
+    
+    QHttpRequestHeader m_curRequest;
 };
 
 #endif
diff -Naur mythtv-0.18-old/libs/libmyth/libmyth.pro mythtv-0.18-new/libs/libmyth/libmyth.pro
--- mythtv-0.18-old/libs/libmyth/libmyth.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmyth/libmyth.pro	2005-05-14 06:54:35.222658743 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0
+VERSION = 0.18.1
 
 # Input
 HEADERS += dialogbox.h lcddevice.h mythcontext.h mythwidgets.h oldsettings.h  
@@ -18,7 +18,7 @@
 HEADERS += managedlist.h DisplayRes.h volumebase.h audiooutputbase.h
 HEADERS += dbsettings.h screensaver-null.h output.h visual.h
 HEADERS += langsettings.h audiooutputnull.h
-HEADERS += DisplayResScreen.h util-x11.h mythdeque.h
+HEADERS += DisplayResScreen.h util-x11.h mythdeque.h qmdcodec.h
 
 SOURCES += dialogbox.cpp lcddevice.cpp mythcontext.cpp mythwidgets.cpp 
 SOURCES += oldsettings.cpp remotefile.cpp settings.cpp themedmenu.cpp
@@ -29,7 +29,7 @@
 SOURCES += volumecontrol.cpp volumebase.cpp audiooutputbase.cpp
 SOURCES += dbsettings.cpp screensaver.cpp screensaver-null.cpp output.cpp
 SOURCES += langsettings.cpp mythdbcon.cpp audiooutputnull.cpp
-SOURCES += DisplayResScreen.cpp util-x11.cpp
+SOURCES += DisplayResScreen.cpp util-x11.cpp qmdcodec.cpp
 
 INCLUDEPATH += ../libmythsamplerate ../libmythsoundtouch ../..
 DEPENDPATH += ../libmythsamplerate ../libmythsoundtouch
@@ -53,7 +53,7 @@
 inc.files += settings.h uitypes.h xmlparse.h mythplugin.h mythdialogs.h
 inc.files += audiooutput.h inetcomms.h httpcomms.h mythmedia.h mythwizard.h
 inc.files += uilistbtntype.h uiphoneentry.h generictree.h managedlist.h
-inc.files += visual.h volumebase.h output.h langsettings.h
+inc.files += visual.h volumebase.h output.h langsettings.h qmdcodec.h
 
 using_oss {
     DEFINES += USING_OSS
diff -Naur mythtv-0.18-old/libs/libmyth/mythcontext.h mythtv-0.18-new/libs/libmyth/mythcontext.h
--- mythtv-0.18-old/libs/libmyth/mythcontext.h	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmyth/mythcontext.h	2005-05-14 06:54:35.222658743 -0700
@@ -162,7 +162,7 @@
     void *m_data;
 };
 
-#define MYTH_BINARY_VERSION "0.18.20050409-1"
+#define MYTH_BINARY_VERSION "0.18.1.20050510-1"
 #define MYTH_PROTO_VERSION "15"
 
 extern int print_verbose_messages;
diff -Naur mythtv-0.18-old/libs/libmyth/qmdcodec.cpp mythtv-0.18-new/libs/libmyth/qmdcodec.cpp
--- mythtv-0.18-old/libs/libmyth/qmdcodec.cpp	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.18-new/libs/libmyth/qmdcodec.cpp	2005-05-14 06:54:35.224658516 -0700
@@ -0,0 +1,1136 @@
+/*
+   Copyright (C) 2000-2001 Dawit Alemayehu <adawit@kde.org>
+   Copyright (C) 2001 Rik Hemsley (rikkus) <rik@kde.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License (LGPL)
+   version 2 as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+   RFC 1321 "MD5 Message-Digest Algorithm" Copyright (C) 1991-1992.
+   RSA Data Security, Inc. Created 1991. All rights reserved.
+
+   The QMD5 class is based on a C++ implementation of
+   "RSA Data Security, Inc. MD5 Message-Digest Algorithm" by
+   Mordechai T. Abzug,	Copyright (c) 1995.  This implementation
+   passes the test-suite as defined in RFC 1321.
+
+   The encoding and decoding utilities in QCodecs with the exception of
+   quoted-printable are based on the java implementation in HTTPClient
+   package by Ronald Tschalär Copyright (C) 1996-1999.
+
+   The quoted-printable codec as described in RFC 2045, section 6.7. is by
+   Rik Hemsley (C) 2001.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "qmdcodec.h"
+
+#define QMD5_S11 7
+#define QMD5_S12 12
+#define QMD5_S13 17
+#define QMD5_S14 22
+#define QMD5_S21 5
+#define QMD5_S22 9
+#define QMD5_S23 14
+#define QMD5_S24 20
+#define QMD5_S31 4
+#define QMD5_S32 11
+#define QMD5_S33 16
+#define QMD5_S34 23
+#define QMD5_S41 6
+#define QMD5_S42 10
+#define QMD5_S43 15
+#define QMD5_S44 21
+
+const char QCodecs::Base64EncMap[64] =
+{
+  0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+  0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
+  0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+  0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
+  0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
+  0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
+  0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
+  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F
+};
+
+const char QCodecs::Base64DecMap[128] =
+{
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3F,
+  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
+  0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
+  0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
+  0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
+  0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
+  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
+  0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
+  0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+const char QCodecs::UUEncMap[64] =
+{
+  0x60, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
+  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
+  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+  0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
+  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+  0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F
+};
+
+const char QCodecs::UUDecMap[128] =
+{
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
+  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
+  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+const char QCodecs::hexChars[16] =
+{
+  '0', '1', '2', '3', '4', '5', '6', '7',
+  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
+};
+
+const unsigned int QCodecs::maxQPLineLength = 70;
+
+
+/******************************** QCodecs ********************************/
+// strchr(3) for broken systems.
+static int rikFindChar(register const char * _s, const char c)
+{
+  register const char * s = _s;
+
+  while (true)
+  {
+    if ((0 == *s) || (c == *s)) break; ++s;
+    if ((0 == *s) || (c == *s)) break; ++s;
+    if ((0 == *s) || (c == *s)) break; ++s;
+    if ((0 == *s) || (c == *s)) break; ++s;
+  }
+
+  return s - _s;
+}
+
+QCString QCodecs::quotedPrintableEncode(const QByteArray& in, bool useCRLF)
+{
+  QByteArray out;
+  quotedPrintableEncode (in, out, useCRLF);
+  return QCString (out.data(), out.size()+1);
+}
+
+QCString QCodecs::quotedPrintableEncode(const QCString& str, bool useCRLF)
+{
+  if (str.isEmpty())
+    return "";
+
+  QByteArray in (str.length());
+  memcpy (in.data(), str.data(), str.length());
+  return quotedPrintableEncode(in, useCRLF);
+}
+
+void QCodecs::quotedPrintableEncode(const QByteArray& in, QByteArray& out, bool useCRLF)
+{
+  out.resize (0);
+  if (in.isEmpty())
+    return;
+
+  char *cursor;
+  const char *data;
+  unsigned int lineLength;
+  unsigned int pos;
+
+  const unsigned int length = in.size();
+  const unsigned int end = length - 1;
+
+
+  // Reasonable guess for output size when we're encoding
+  // mostly-ASCII data. It doesn't really matter, because
+  // the underlying allocation routines are quite efficient,
+  // but it's nice to have 0 allocations in many cases.
+  out.resize ((length*12)/10);
+  cursor = out.data();
+  data = in.data();
+  lineLength = 0;
+  pos = 0;
+
+  for (unsigned int i = 0; i < length; i++)
+  {
+    unsigned char c (data[i]);
+
+    // check if we have to enlarge the output buffer, use
+    // a safety margin of 16 byte
+    pos = cursor-out.data();
+    if (out.size()-pos < 16) {
+      out.resize(out.size()+4096);
+      cursor = out.data()+pos;
+    }
+
+    // Plain ASCII chars just go straight out.
+
+    if ((c >= 33) && (c <= 126) && ('=' != c))
+    {
+      *cursor++ = c;
+      ++lineLength;
+    }
+
+    // Spaces need some thought. We have to encode them at eol (or eof).
+
+    else if (' ' == c)
+    {
+      if
+        (
+         (i >= length)
+         ||
+         ((i < end) && ((useCRLF && ('\r' == data[i + 1]) && ('\n' == data[i + 2]))
+                        ||
+                        (!useCRLF && ('\n' == data[i + 1]))))
+        )
+      {
+        *cursor++ = '=';
+        *cursor++ = '2';
+        *cursor++ = '0';
+
+        lineLength += 3;
+      }
+      else
+      {
+        *cursor++ = ' ';
+        ++lineLength;
+      }
+    }
+    // If we find a line break, just let it through.
+    else if ((useCRLF && ('\r' == c) && (i < end) && ('\n' == data[i + 1])) ||
+             (!useCRLF && ('\n' == c)))
+    {
+      lineLength = 0;
+
+      if (useCRLF) {
+        *cursor++ = '\r';
+        *cursor++ = '\n';
+        ++i;
+      } else {
+        *cursor++ = '\n';
+      }
+    }
+
+    // Anything else is converted to =XX.
+
+    else
+    {
+      *cursor++ = '=';
+      *cursor++ = hexChars[c / 16];
+      *cursor++ = hexChars[c % 16];
+
+      lineLength += 3;
+    }
+
+    // If we're approaching the maximum line length, do a soft line break.
+
+    if ((lineLength > maxQPLineLength) && (i < end))
+    {
+      if (useCRLF) {
+        *cursor++ = '=';
+        *cursor++ = '\r';
+        *cursor++ = '\n';
+      } else {
+        *cursor++ = '=';
+        *cursor++ = '\n';
+      }
+
+      lineLength = 0;
+    }
+  }
+
+  out.truncate(cursor - out.data());
+}
+
+QCString QCodecs::quotedPrintableDecode(const QByteArray & in)
+{
+  QByteArray out;
+  quotedPrintableDecode (in, out);
+  return QCString (out.data(), out.size()+1);
+}
+
+QCString QCodecs::quotedPrintableDecode(const QCString & str)
+{
+  if (str.isEmpty())
+    return "";
+
+  QByteArray in (str.length());
+  memcpy (in.data(), str.data(), str.length());
+  return quotedPrintableDecode (in);
+}
+
+void QCodecs::quotedPrintableDecode(const QByteArray& in, QByteArray& out)
+{
+  // clear out the output buffer
+  out.resize (0);
+  if (in.isEmpty())
+      return;
+
+  char *cursor;
+  const char *data;
+  const unsigned int length = in.size();
+
+  data = in.data();
+  out.resize (length);
+  cursor = out.data();
+
+  for (unsigned int i = 0; i < length; i++)
+  {
+    char c(in.at(i));
+
+    if ('=' == c)
+    {
+      if (i < length - 2)
+      {
+        char c1 = in.at(i + 1);
+        char c2 = in.at(i + 2);
+
+        if (('\n' == c1) || ('\r' == c1 && '\n' == c2))
+        {
+          // Soft line break. No output.
+          if ('\r' == c1)
+            i += 2;        // CRLF line breaks
+          else
+            i += 1;
+        }
+        else
+        {
+          // =XX encoded byte.
+
+          int hexChar0 = rikFindChar(hexChars, c1);
+          int hexChar1 = rikFindChar(hexChars, c2);
+
+          if (hexChar0 < 16 && hexChar1 < 16)
+          {
+            *cursor++ = char((hexChar0 * 16) | hexChar1);
+            i += 2;
+          }
+        }
+      }
+    }
+    else
+    {
+      *cursor++ = c;
+    }
+  }
+
+  out.truncate(cursor - out.data());
+}
+
+QCString QCodecs::base64Encode( const QCString& str, bool insertLFs )
+{
+    if ( str.isEmpty() )
+        return "";
+
+    QByteArray in (str.length());
+    memcpy( in.data(), str.data(), str.length() );
+    return base64Encode( in, insertLFs );
+}
+
+QCString QCodecs::base64Encode( const QByteArray& in, bool insertLFs )
+{
+    QByteArray out;
+    base64Encode( in, out, insertLFs );
+    return QCString( out.data(), out.size()+1 );
+}
+
+void QCodecs::base64Encode( const QByteArray& in, QByteArray& out,
+                            bool insertLFs )
+{
+    // clear out the output buffer
+    out.resize (0);
+    if ( in.isEmpty() )
+        return;
+
+    unsigned int sidx = 0;
+    unsigned int didx = 0;
+    const char* data = in.data();
+    const unsigned int len = in.size();
+
+    unsigned int out_len = ((len+2)/3)*4;
+
+    // Deal with the 76 characters or less per
+    // line limit specified in RFC 2045 on a
+    // pre request basis.
+    insertLFs = (insertLFs && out_len > 76);
+    if ( insertLFs )
+      out_len += ((out_len-1)/76);
+
+    int count = 0;
+    out.resize( out_len );
+
+    // 3-byte to 4-byte conversion + 0-63 to ascii printable conversion
+    if ( len > 1 )
+    {
+        while (sidx < len-2)
+        {
+            if ( insertLFs )
+            {
+                if ( count && (count%76) == 0 )
+                    out.data()[didx++] = '\n';
+                count += 4;
+            }
+            out.data()[didx++] = Base64EncMap[(data[sidx] >> 2) & 077];
+            out.data()[didx++] = Base64EncMap[(data[sidx+1] >> 4) & 017 |
+                                       (data[sidx] << 4) & 077];
+            out.data()[didx++] = Base64EncMap[(data[sidx+2] >> 6) & 003 |
+                                       (data[sidx+1] << 2) & 077];
+            out.data()[didx++] = Base64EncMap[data[sidx+2] & 077];
+            sidx += 3;
+        }
+    }
+
+    if (sidx < len)
+    {
+        if ( insertLFs && (count > 0) && (count%76) == 0 )
+           out.data()[didx++] = '\n';
+
+        out.data()[didx++] = Base64EncMap[(data[sidx] >> 2) & 077];
+        if (sidx < len-1)
+        {
+            out.data()[didx++] = Base64EncMap[(data[sidx+1] >> 4) & 017 |
+												(data[sidx] << 4) & 077];
+            out.data()[didx++] = Base64EncMap[(data[sidx+1] << 2) & 077];
+        }
+        else
+        {
+            out.data()[didx++] = Base64EncMap[(data[sidx] << 4) & 077];
+        }
+    }
+
+    // Add padding
+    while (didx < out.size())
+    {
+        out.data()[didx] = '=';
+        didx++;
+    }
+}
+
+QCString QCodecs::base64Decode( const QCString& str )
+{
+    if ( str.isEmpty() )
+        return "";
+
+    QByteArray in( str.length() );
+    memcpy( in.data(), str.data(), str.length() );
+    return base64Decode( in );
+}
+
+QCString QCodecs::base64Decode( const QByteArray& in )
+{
+    QByteArray out;
+    base64Decode( in, out );
+    return QCString( out.data(), out.size()+1 );
+}
+
+void QCodecs::base64Decode( const QByteArray& in, QByteArray& out )
+{
+    out.resize(0);
+    if ( in.isEmpty() )
+        return;
+
+    unsigned int count = 0;
+    unsigned int len = in.size(), tail = len;
+    const char* data = in.data();
+
+    // Deal with possible *nix "BEGIN" marker!!
+    while ( count < len && (data[count] == '\n' || data[count] == '\r' ||
+            data[count] == '\t' || data[count] == ' ') )
+        count++;
+
+#ifdef _WIN32
+    if ( strnicmp(data+count, "begin", 5) == 0 )
+#else
+	if ( strncasecmp(data+count, "begin", 5) == 0 )
+#endif
+    {
+        count += 5;
+        while ( count < len && data[count] != '\n' && data[count] != '\r' )
+            count++;
+
+        while ( count < len && (data[count] == '\n' || data[count] == '\r') )
+            count ++;
+
+        data += count;
+        tail = (len -= count);
+    }
+
+    // Find the tail end of the actual encoded data even if
+    // there is/are trailing CR and/or LF.
+    while ( data[tail-1] == '=' || data[tail-1] == '\n' ||
+            data[tail-1] == '\r' )
+        if ( data[--tail] != '=' ) len = tail;
+
+    unsigned int outIdx = 0;
+    out.resize( (count=len) );
+    for (unsigned int idx = 0; idx < count; idx++)
+    {
+        // Adhere to RFC 2045 and ignore characters
+        // that are not part of the encoding table.
+        unsigned char ch = data[idx];
+        if ((ch > 47 && ch < 58) || (ch > 64 && ch < 91) ||
+            (ch > 96 && ch < 123) || ch == '+' || ch == '/' || ch == '=')
+        {
+            out.data()[outIdx++] = Base64DecMap[ch];
+        }
+        else
+        {
+            len--;
+            tail--;
+        }
+    }
+
+    // kdDebug() << "Tail size = " << tail << ", Length size = " << len << endl;
+
+    // 4-byte to 3-byte conversion
+    len = (tail>(len/4)) ? tail-(len/4) : 0;
+    unsigned int sidx = 0, didx = 0;
+    if ( len > 1 )
+    {
+      while (didx < len-2)
+      {
+          out.data()[didx] = (((out.at(sidx) << 2) & 255) | ((out.at(sidx+1) >> 4) & 003));
+          out.data()[didx+1] = (((out.at(sidx+1) << 4) & 255) | ((out.at(sidx+2) >> 2) & 017));
+          out.data()[didx+2] = (((out.at(sidx+2) << 6) & 255) | (out.at(sidx+3) & 077));
+          sidx += 4;
+          didx += 3;
+      }
+    }
+
+    if (didx < len)
+        out.data()[didx] = (((out.at(sidx) << 2) & 255) | ((out.at(sidx+1) >> 4) & 003));
+
+    if (++didx < len )
+        out.data()[didx] = (((out.at(sidx+1) << 4) & 255) | ((out.at(sidx+2) >> 2) & 017));
+
+    // Resize the output buffer
+    if ( len == 0 || len < out.size() )
+      out.resize(len);
+}
+
+QCString QCodecs::uuencode( const QCString& str )
+{
+    if ( str.isEmpty() )
+        return "";
+
+    QByteArray in;
+    in.resize( str.length() );
+    memcpy( in.data(), str.data(), str.length() );
+    return uuencode( in );
+}
+
+QCString QCodecs::uuencode( const QByteArray& in )
+{
+    QByteArray out;
+    uuencode( in, out );
+    return QCString( out.data(), out.size()+1 );
+}
+
+void QCodecs::uuencode( const QByteArray& in, QByteArray& out )
+{
+    out.resize( 0 );
+    if( in.isEmpty() )
+        return;
+
+    unsigned int sidx = 0;
+    unsigned int didx = 0;
+    unsigned int line_len = 45;
+
+    const char nl[] = "\n";
+    const char* data = in.data();
+    const unsigned int nl_len = strlen(nl);
+    const unsigned int len = in.size();
+
+    out.resize( (len+2)/3*4 + ((len+line_len-1)/line_len)*(nl_len+1) );
+    // split into lines, adding line-length and line terminator
+    while (sidx+line_len < len)
+    {
+        // line length
+        out.data()[didx++] = UUEncMap[line_len];
+
+        // 3-byte to 4-byte conversion + 0-63 to ascii printable conversion
+        for (unsigned int end = sidx+line_len; sidx < end; sidx += 3)
+        {
+            out.data()[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
+            out.data()[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
+                                   (data[sidx] << 4) & 077];
+            out.data()[didx++] = UUEncMap[(data[sidx+2] >> 6) & 003 |
+                                (data[sidx+1] << 2) & 077];
+            out.data()[didx++] = UUEncMap[data[sidx+2] & 077];
+        }
+
+        // line terminator
+        //for (unsigned int idx=0; idx < nl_len; idx++)
+        //out[didx++] = nl[idx];
+        memcpy(out.data()+didx, nl, nl_len);
+        didx += nl_len;
+    }
+
+    // line length
+    out.data()[didx++] = UUEncMap[len-sidx];
+    // 3-byte to 4-byte conversion + 0-63 to ascii printable conversion
+    while (sidx+2 < len)
+    {
+        out.data()[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
+        out.data()[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
+                               (data[sidx] << 4) & 077];
+        out.data()[didx++] = UUEncMap[(data[sidx+2] >> 6) & 003 |
+                               (data[sidx+1] << 2) & 077];
+        out.data()[didx++] = UUEncMap[data[sidx+2] & 077];
+        sidx += 3;
+    }
+
+    if (sidx < len-1)
+    {
+        out.data()[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
+        out.data()[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
+                               (data[sidx] << 4) & 077];
+        out.data()[didx++] = UUEncMap[(data[sidx+1] << 2) & 077];
+        out.data()[didx++] = UUEncMap[0];
+    }
+    else if (sidx < len)
+    {
+        out.data()[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
+        out.data()[didx++] = UUEncMap[(data[sidx] << 4) & 077];
+        out.data()[didx++] = UUEncMap[0];
+        out.data()[didx++] = UUEncMap[0];
+    }
+
+    // line terminator
+    memcpy(out.data()+didx, nl, nl_len);
+    didx += nl_len;
+
+    // sanity check
+    if ( didx != out.size() )
+        out.resize( 0 );
+}
+
+QCString QCodecs::uudecode( const QCString& str )
+{
+    if ( str.isEmpty() )
+        return "";
+
+    QByteArray in;
+    in.resize( str.length() );
+    memcpy( in.data(), str.data(), str.length() );
+    return uudecode( in );
+}
+
+QCString QCodecs::uudecode( const QByteArray& in )
+{
+    QByteArray out;
+    uudecode( in, out );
+    return QCString( out.data(), out.size()+1 );
+}
+
+void QCodecs::uudecode( const QByteArray& in, QByteArray& out )
+{
+    out.resize( 0 );
+    if( in.isEmpty() )
+        return;
+
+    unsigned int sidx = 0;
+    unsigned int didx = 0;
+    unsigned int len = in.size();
+    unsigned int line_len, end;
+    const char* data = in.data();
+
+    // Deal with *nix "BEGIN"/"END" separators!!
+    unsigned int count = 0;
+    while ( count < len && (data[count] == '\n' || data[count] == '\r' ||
+            data[count] == '\t' || data[count] == ' ') )
+        count ++;
+
+    bool hasLF = false;
+
+#ifdef _WIN32
+    if ( strnicmp( data+count, "begin", 5) == 0 )
+#else
+	if ( strncasecmp( data+count, "begin", 5) == 0 )
+#endif
+    {
+        count += 5;
+        while ( count < len && data[count] != '\n' && data[count] != '\r' )
+            count ++;
+
+        while ( count < len && (data[count] == '\n' || data[count] == '\r') )
+            count ++;
+
+        data += count;
+        len -= count;
+        hasLF = true;
+    }
+
+    out.resize( len/4*3 );
+    while ( sidx < len )
+    {
+        // get line length (in number of encoded octets)
+        line_len = UUDecMap[ (unsigned char) data[sidx++]];
+        // ascii printable to 0-63 and 4-byte to 3-byte conversion
+        end = didx+line_len;
+        char A, B, C, D;
+        if (end > 2) {
+          while (didx < end-2)
+          {
+             A = UUDecMap[(unsigned char) data[sidx]];
+             B = UUDecMap[(unsigned char) data[sidx+1]];
+             C = UUDecMap[(unsigned char) data[sidx+2]];
+             D = UUDecMap[(unsigned char) data[sidx+3]];
+             out.data()[didx++] = ( ((A << 2) & 255) | ((B >> 4) & 003) );
+             out.data()[didx++] = ( ((B << 4) & 255) | ((C >> 2) & 017) );
+             out.data()[didx++] = ( ((C << 6) & 255) | (D & 077) );
+             sidx += 4;
+          }
+        }
+
+        if (didx < end)
+        {
+            A = UUDecMap[(unsigned char) data[sidx]];
+            B = UUDecMap[(unsigned char) data[sidx+1]];
+            out.data()[didx++] = ( ((A << 2) & 255) | ((B >> 4) & 003) );
+        }
+
+        if (didx < end)
+        {
+            B = UUDecMap[(unsigned char) data[sidx+1]];
+            C = UUDecMap[(unsigned char) data[sidx+2]];
+            out.data()[didx++] = ( ((B << 4) & 255) | ((C >> 2) & 017) );
+        }
+
+        // skip padding
+        while (sidx < len  && data[sidx] != '\n' && data[sidx] != '\r')
+            sidx++;
+
+        // skip end of line
+        while (sidx < len  && (data[sidx] == '\n' || data[sidx] == '\r'))
+            sidx++;
+
+        // skip the "END" separator when present.
+#ifdef _WIN32
+        if ( hasLF && strnicmp( data+sidx, "end", 3) == 0 )
+#else
+		if ( hasLF && strncasecmp( data+sidx, "end", 3) == 0 )
+#endif
+            break;
+    }
+
+    if ( didx < out.size()  )
+        out.resize( didx );
+}
+
+/******************************** QMD5 ********************************/
+QMD5::QMD5()
+{
+    init();
+}
+
+QMD5::QMD5(const char *in, int len)
+{
+    init();
+    update(in, len);
+}
+
+QMD5::QMD5(const QByteArray& in)
+{
+    init();
+    update( in );
+}
+
+QMD5::QMD5(const QCString& in)
+{
+    init();
+    update( in );
+}
+
+void QMD5::update(const QByteArray& in)
+{
+    update(in.data(), int(in.size()));
+}
+
+void QMD5::update(const QCString& in)
+{
+    update(in.data(), int(in.length()));
+}
+
+void QMD5::update(const unsigned char* in, int len)
+{
+    if (len < 0)
+        len = qstrlen(reinterpret_cast<const char*>(in));
+
+    if (!len)
+        return;
+
+    if (m_finalized) {
+        qWarning("QMD5::update called after state was finalized!");
+        return;
+    }
+
+    Q_UINT32 in_index;
+    Q_UINT32 buffer_index;
+    Q_UINT32 buffer_space;
+    Q_UINT32 in_length = static_cast<Q_UINT32>( len );
+
+    buffer_index = static_cast<Q_UINT32>((m_count[0] >> 3) & 0x3F);
+
+    if (  (m_count[0] += (in_length << 3))<(in_length << 3) )
+        m_count[1]++;
+
+    m_count[1] += (in_length >> 29);
+    buffer_space = 64 - buffer_index;
+
+    if (in_length >= buffer_space)
+    {
+        memcpy (m_buffer + buffer_index, in, buffer_space);
+        transform (m_buffer);
+
+        for (in_index = buffer_space; in_index + 63 < in_length;
+             in_index += 64)
+            transform (reinterpret_cast<const unsigned char*>(in+in_index));
+
+        buffer_index = 0;
+    }
+    else
+        in_index=0;
+
+    memcpy(m_buffer+buffer_index, in+in_index, in_length-in_index);
+}
+
+bool QMD5::update(QIODevice& file)
+{
+    char buffer[1024];
+    int len;
+
+    while ((len=file.readBlock(reinterpret_cast<char*>(buffer), sizeof(buffer))) > 0)
+        update(buffer, len);
+
+    return file.atEnd();
+}
+
+void QMD5::finalize ()
+{
+    if (m_finalized) return;
+
+    Q_UINT8 bits[8];
+    Q_UINT32 index, padLen;
+    static unsigned char PADDING[64]=
+    {
+        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+    };
+
+    encode (bits, m_count, 8);
+    //memcpy( bits, m_count, 8 );
+
+    // Pad out to 56 mod 64.
+    index = static_cast<Q_UINT32>((m_count[0] >> 3) & 0x3f);
+    padLen = (index < 56) ? (56 - index) : (120 - index);
+    update (reinterpret_cast<const char*>(PADDING), padLen);
+
+    // Append length (before padding)
+    update (reinterpret_cast<const char*>(bits), 8);
+
+    // Store state in digest
+    encode (m_digest, m_state, 16);
+    //memcpy( m_digest, m_state, 16 );
+
+    // Fill sensitive information with zero's
+    memset ( (void *)m_buffer, 0, sizeof(*m_buffer));
+
+    m_finalized = true;
+}
+
+
+bool QMD5::verify( const QMD5::Digest& digest)
+{
+    finalize();
+    return (0 == memcmp(rawDigest(), digest, sizeof(QMD5::Digest)));
+}
+
+bool QMD5::verify( const QCString& hexdigest)
+{
+    finalize();
+    return (0 == strcmp(hexDigest().data(), hexdigest));
+}
+
+const QMD5::Digest& QMD5::rawDigest()
+{
+    finalize();
+    return m_digest;
+}
+
+void QMD5::rawDigest( QMD5::Digest& bin )
+{
+    finalize();
+    memcpy( bin, m_digest, 16 );
+}
+
+
+QCString QMD5::hexDigest()
+{
+    QCString s(33);
+
+    finalize();
+    sprintf(s.data(), "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
+            m_digest[0], m_digest[1], m_digest[2], m_digest[3], m_digest[4], m_digest[5],
+            m_digest[6], m_digest[7], m_digest[8], m_digest[9], m_digest[10], m_digest[11],
+            m_digest[12], m_digest[13], m_digest[14], m_digest[15]);
+
+    return s;
+}
+
+void QMD5::hexDigest(QCString& s)
+{
+    finalize();
+    s.resize(33);
+    sprintf(s.data(), "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
+            m_digest[0], m_digest[1], m_digest[2], m_digest[3], m_digest[4], m_digest[5],
+            m_digest[6], m_digest[7], m_digest[8], m_digest[9], m_digest[10], m_digest[11],
+            m_digest[12], m_digest[13], m_digest[14], m_digest[15]);
+}
+
+QCString QMD5::base64Digest()
+{
+    QByteArray ba(16);
+
+    finalize();
+    memcpy(ba.data(), m_digest, 16);
+    return QCodecs::base64Encode(ba);
+}
+
+
+void QMD5::init()
+{
+    d = 0;
+    reset();
+}
+
+void QMD5::reset()
+{
+    m_finalized = false;
+
+    m_count[0] = 0;
+    m_count[1] = 0;
+
+    m_state[0] = 0x67452301;
+    m_state[1] = 0xefcdab89;
+    m_state[2] = 0x98badcfe;
+    m_state[3] = 0x10325476;
+
+    memset ( m_buffer, 0, sizeof(*m_buffer));
+    memset ( m_digest, 0, sizeof(*m_digest));
+}
+
+void QMD5::transform( const unsigned char block[64] )
+{
+
+    Q_UINT32 a = m_state[0], b = m_state[1], c = m_state[2], d = m_state[3], x[16];
+
+    decode (x, block, 64);
+    //memcpy( x, block, 64 );
+
+    Q_ASSERT(!m_finalized);  // not just a user error, since the method is private
+
+    /* Round 1 */
+    FF (a, b, c, d, x[ 0], QMD5_S11, 0xd76aa478); /* 1 */
+    FF (d, a, b, c, x[ 1], QMD5_S12, 0xe8c7b756); /* 2 */
+    FF (c, d, a, b, x[ 2], QMD5_S13, 0x242070db); /* 3 */
+    FF (b, c, d, a, x[ 3], QMD5_S14, 0xc1bdceee); /* 4 */
+    FF (a, b, c, d, x[ 4], QMD5_S11, 0xf57c0faf); /* 5 */
+    FF (d, a, b, c, x[ 5], QMD5_S12, 0x4787c62a); /* 6 */
+    FF (c, d, a, b, x[ 6], QMD5_S13, 0xa8304613); /* 7 */
+    FF (b, c, d, a, x[ 7], QMD5_S14, 0xfd469501); /* 8 */
+    FF (a, b, c, d, x[ 8], QMD5_S11, 0x698098d8); /* 9 */
+    FF (d, a, b, c, x[ 9], QMD5_S12, 0x8b44f7af); /* 10 */
+    FF (c, d, a, b, x[10], QMD5_S13, 0xffff5bb1); /* 11 */
+    FF (b, c, d, a, x[11], QMD5_S14, 0x895cd7be); /* 12 */
+    FF (a, b, c, d, x[12], QMD5_S11, 0x6b901122); /* 13 */
+    FF (d, a, b, c, x[13], QMD5_S12, 0xfd987193); /* 14 */
+    FF (c, d, a, b, x[14], QMD5_S13, 0xa679438e); /* 15 */
+    FF (b, c, d, a, x[15], QMD5_S14, 0x49b40821); /* 16 */
+
+    /* Round 2 */
+    GG (a, b, c, d, x[ 1], QMD5_S21, 0xf61e2562); /* 17 */
+    GG (d, a, b, c, x[ 6], QMD5_S22, 0xc040b340); /* 18 */
+    GG (c, d, a, b, x[11], QMD5_S23, 0x265e5a51); /* 19 */
+    GG (b, c, d, a, x[ 0], QMD5_S24, 0xe9b6c7aa); /* 20 */
+    GG (a, b, c, d, x[ 5], QMD5_S21, 0xd62f105d); /* 21 */
+    GG (d, a, b, c, x[10], QMD5_S22,  0x2441453); /* 22 */
+    GG (c, d, a, b, x[15], QMD5_S23, 0xd8a1e681); /* 23 */
+    GG (b, c, d, a, x[ 4], QMD5_S24, 0xe7d3fbc8); /* 24 */
+    GG (a, b, c, d, x[ 9], QMD5_S21, 0x21e1cde6); /* 25 */
+    GG (d, a, b, c, x[14], QMD5_S22, 0xc33707d6); /* 26 */
+    GG (c, d, a, b, x[ 3], QMD5_S23, 0xf4d50d87); /* 27 */
+    GG (b, c, d, a, x[ 8], QMD5_S24, 0x455a14ed); /* 28 */
+    GG (a, b, c, d, x[13], QMD5_S21, 0xa9e3e905); /* 29 */
+    GG (d, a, b, c, x[ 2], QMD5_S22, 0xfcefa3f8); /* 30 */
+    GG (c, d, a, b, x[ 7], QMD5_S23, 0x676f02d9); /* 31 */
+    GG (b, c, d, a, x[12], QMD5_S24, 0x8d2a4c8a); /* 32 */
+
+    /* Round 3 */
+    HH (a, b, c, d, x[ 5], QMD5_S31, 0xfffa3942); /* 33 */
+    HH (d, a, b, c, x[ 8], QMD5_S32, 0x8771f681); /* 34 */
+    HH (c, d, a, b, x[11], QMD5_S33, 0x6d9d6122); /* 35 */
+    HH (b, c, d, a, x[14], QMD5_S34, 0xfde5380c); /* 36 */
+    HH (a, b, c, d, x[ 1], QMD5_S31, 0xa4beea44); /* 37 */
+    HH (d, a, b, c, x[ 4], QMD5_S32, 0x4bdecfa9); /* 38 */
+    HH (c, d, a, b, x[ 7], QMD5_S33, 0xf6bb4b60); /* 39 */
+    HH (b, c, d, a, x[10], QMD5_S34, 0xbebfbc70); /* 40 */
+    HH (a, b, c, d, x[13], QMD5_S31, 0x289b7ec6); /* 41 */
+    HH (d, a, b, c, x[ 0], QMD5_S32, 0xeaa127fa); /* 42 */
+    HH (c, d, a, b, x[ 3], QMD5_S33, 0xd4ef3085); /* 43 */
+    HH (b, c, d, a, x[ 6], QMD5_S34,  0x4881d05); /* 44 */
+    HH (a, b, c, d, x[ 9], QMD5_S31, 0xd9d4d039); /* 45 */
+    HH (d, a, b, c, x[12], QMD5_S32, 0xe6db99e5); /* 46 */
+    HH (c, d, a, b, x[15], QMD5_S33, 0x1fa27cf8); /* 47 */
+    HH (b, c, d, a, x[ 2], QMD5_S34, 0xc4ac5665); /* 48 */
+
+    /* Round 4 */
+    II (a, b, c, d, x[ 0], QMD5_S41, 0xf4292244); /* 49 */
+    II (d, a, b, c, x[ 7], QMD5_S42, 0x432aff97); /* 50 */
+    II (c, d, a, b, x[14], QMD5_S43, 0xab9423a7); /* 51 */
+    II (b, c, d, a, x[ 5], QMD5_S44, 0xfc93a039); /* 52 */
+    II (a, b, c, d, x[12], QMD5_S41, 0x655b59c3); /* 53 */
+    II (d, a, b, c, x[ 3], QMD5_S42, 0x8f0ccc92); /* 54 */
+    II (c, d, a, b, x[10], QMD5_S43, 0xffeff47d); /* 55 */
+    II (b, c, d, a, x[ 1], QMD5_S44, 0x85845dd1); /* 56 */
+    II (a, b, c, d, x[ 8], QMD5_S41, 0x6fa87e4f); /* 57 */
+    II (d, a, b, c, x[15], QMD5_S42, 0xfe2ce6e0); /* 58 */
+    II (c, d, a, b, x[ 6], QMD5_S43, 0xa3014314); /* 59 */
+    II (b, c, d, a, x[13], QMD5_S44, 0x4e0811a1); /* 60 */
+    II (a, b, c, d, x[ 4], QMD5_S41, 0xf7537e82); /* 61 */
+    II (d, a, b, c, x[11], QMD5_S42, 0xbd3af235); /* 62 */
+    II (c, d, a, b, x[ 2], QMD5_S43, 0x2ad7d2bb); /* 63 */
+    II (b, c, d, a, x[ 9], QMD5_S44, 0xeb86d391); /* 64 */
+
+    m_state[0] += a;
+    m_state[1] += b;
+    m_state[2] += c;
+    m_state[3] += d;
+
+    memset ( static_cast<void *>(x), 0, sizeof(x) );
+}
+
+inline Q_UINT32 QMD5::rotate_left (Q_UINT32 x, Q_UINT32 n)
+{
+    return (x << n) | (x >> (32-n))  ;
+}
+
+inline Q_UINT32 QMD5::F (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
+{
+    return (x & y) | (~x & z);
+}
+
+inline Q_UINT32 QMD5::G (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
+{
+    return (x & z) | (y & ~z);
+}
+
+inline Q_UINT32 QMD5::H (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
+{
+    return x ^ y ^ z;
+}
+
+inline Q_UINT32 QMD5::I (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
+{
+    return y ^ (x | ~z);
+}
+
+void QMD5::FF ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
+                       Q_UINT32 x, Q_UINT32  s, Q_UINT32 ac )
+{
+    a += F(b, c, d) + x + ac;
+    a = rotate_left (a, s) +b;
+}
+
+void QMD5::GG ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
+                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac)
+{
+    a += G(b, c, d) + x + ac;
+    a = rotate_left (a, s) +b;
+}
+
+void QMD5::HH ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
+                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac )
+{
+    a += H(b, c, d) + x + ac;
+    a = rotate_left (a, s) +b;
+}
+
+void QMD5::II ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
+                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac )
+{
+    a += I(b, c, d) + x + ac;
+    a = rotate_left (a, s) +b;
+}
+
+
+void QMD5::encode ( unsigned char* output, Q_UINT32 *in, Q_UINT32 len )
+{
+#if !defined(WORDS_BIGENDIAN)
+    memcpy(output, in, len);
+
+#else
+    Q_UINT32 i, j;
+    for (i = 0, j = 0; j < len; i++, j += 4)
+    {
+        output[j]   = static_cast<Q_UINT8>((in[i] & 0xff));
+        output[j+1] = static_cast<Q_UINT8>(((in[i] >> 8) & 0xff));
+        output[j+2] = static_cast<Q_UINT8>(((in[i] >> 16) & 0xff));
+        output[j+3] = static_cast<Q_UINT8>(((in[i] >> 24) & 0xff));
+    }
+#endif
+}
+
+// Decodes in (Q_UINT8) into output (Q_UINT32). Assumes len is a
+// multiple of 4.
+void QMD5::decode (Q_UINT32 *output, const unsigned char* in, Q_UINT32 len)
+{
+#if !defined(WORDS_BIGENDIAN)
+    memcpy(output, in, len);
+
+#else
+    Q_UINT32 i, j;
+    for (i = 0, j = 0; j < len; i++, j += 4)
+        output[i] = static_cast<Q_UINT32>(in[j]) |
+                    (static_cast<Q_UINT32>(in[j+1]) << 8)  |
+                    (static_cast<Q_UINT32>(in[j+2]) << 16) |
+                    (static_cast<Q_UINT32>(in[j+3]) << 24);
+#endif
+}
diff -Naur mythtv-0.18-old/libs/libmyth/qmdcodec.h mythtv-0.18-new/libs/libmyth/qmdcodec.h
--- mythtv-0.18-old/libs/libmyth/qmdcodec.h	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.18-new/libs/libmyth/qmdcodec.h	2005-05-14 06:54:35.225658402 -0700
@@ -0,0 +1,572 @@
+/*
+   Copyright (C) 2000-2001 Dawit Alemayehu <adawit@kde.org>
+   Copyright (C) 2001 Rik Hemsley (rikkus) <rik@kde.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License (LGPL)
+   version 2 as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+   RFC 1321 "MD5 Message-Digest Algorithm" Copyright (C) 1991-1992.
+   RSA Data Security, Inc. Created 1991. All rights reserved.
+
+   The KMD5 class is based on a C++ implementation of
+   "RSA Data Security, Inc. MD5 Message-Digest Algorithm" by
+   Mordechai T. Abzug,	Copyright (c) 1995.  This implementation
+   passes the test-suite as defined in RFC 1321.
+
+   The encoding and decoding utilities in KCodecs with the exception of
+   quoted-printable are based on the java implementation in HTTPClient
+   package by Ronald Tschalär Copyright (C) 1996-1999.
+
+   The quoted-printable codec as described in RFC 2045, section 6.7. is by
+   Rik Hemsley (C) 2001.
+*/
+
+#ifndef _QMDCODEC_H
+#define _QMDCODEC_H
+
+#define QBase64 QCodecs
+
+#include <qglobal.h>
+#include <qstring.h>
+#include <qiodevice.h>
+
+/**
+ * A wrapper class for the most commonly used encoding and
+ * decoding algorithms.  Currently there is support for encoding
+ * and decoding input using base64, uu and the quoted-printable
+ * specifications.
+ *
+ * @sect Usage:
+ *
+ * <PRE>
+ * QCString input = "Aladdin:open sesame";
+ * QCString result = QCodecs::base64Encode(input);
+ * cout << "Result: " << result.data() << endl;
+ *
+ * Output should be
+ * Result: QWxhZGRpbjpvcGVuIHNlc2FtZQ==
+ * </PRE>
+ *
+ * The above example makes use of the convenience functions
+ * (ones that accept/return null-terminated strings) to encode/decode
+ * a string.  If what you need is to encode or decode binary data, then
+ * it is highly recommended that you use the functions that take an input
+ * and output QByteArray as arguments.  These functions are specifically
+ * tailored for encoding and decoding binary data.
+ *
+ * @short A collection of commonly used encoding and decoding algorithms.
+ * @author Dawit Alemayehu <adawit@kde.org>
+ * @author Rik Hemsley <rik@kde.org>
+ */
+class QCodecs
+{
+public:
+
+  /**
+   * Encodes the given data using the quoted-printable algorithm.
+   *
+   * @param in      data to be encoded.
+   * @param useCRLF if true the input data is expected to have
+   *                CRLF line breaks and the output will have CRLF line
+   *                breaks, too.
+   * @return        quoted-printable encoded data.
+   */
+  static QCString quotedPrintableEncode(const QByteArray & in,
+                                        bool useCRLF = true);
+
+  /**
+   * @overload
+   *
+   * Same as above except it accepts a null terminated
+   * string instead an array.
+   *
+   * @param str     data to be encoded.
+   * @param useCRLF if true the input data is expected to have
+   *                CRLF line breaks and the output will have CRLF line
+   *                breaks, too.
+   * @return        quoted-printable encoded data.
+   */
+  static QCString quotedPrintableEncode(const QCString & str,
+                                        bool useCRLF = true);
+
+  /**
+   * Encodes the given data using the quoted-printable algorithm.
+   *
+   * Use this function if you want the result of the encoding
+   * to be placed in another array which cuts down the number
+   * of copy operation that have to be performed in the process.
+   * This is also the preferred method for encoding binary data.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in      data to be encoded.
+   * @param out     decoded data.
+   * @param useCRLF if true the input data is expected to have
+   *                CRLF line breaks and the output will have CRLF line
+   *                breaks, too.
+   * @return        quoted-printable encoded data.
+   */
+  static void quotedPrintableEncode(const QByteArray & in, QByteArray& out,
+                                    bool useCRLF);
+
+  /**
+   * Decodes a quoted-printable encoded string.
+   *
+   * Accepts data with CRLF or standard unix line breaks.
+   *
+   * @param in  the data to be decoded.
+   * @return    decoded data.
+   */
+  static QCString quotedPrintableDecode(const QByteArray & in);
+
+  /**
+   * @overload
+   *
+   * Same as above except it accepts a null terminated
+   * string instead an array.
+   *
+   * @param str  the data to be decoded.
+   * @return     decoded data.
+   */
+  static QCString quotedPrintableDecode(const QCString & str);
+
+  /**
+   * Decodes a quoted-printable encoded data.
+   *
+   * Accepts data with CRLF or standard unix line breaks.
+   * Use this function if you want the result of the decoding
+   * to be placed in another array which cuts down the number
+   * of copy operation that have to be performed in the process.
+   * This is also the preferred method for decoding an encoded
+   * binary data.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in   data to be encoded.
+   * @param out  decoded data.
+   *
+   * @return     quoted-printable encoded data.
+   */
+  static void quotedPrintableDecode(const QByteArray & in, QByteArray& out);
+
+
+  /**
+   * Encodes the given data using the uuencode algorithm.
+   *
+   * The output is split into lines starting with the number of
+   * encoded octets in the line and ending with a newline.  No
+   * line is longer than 45 octets (60 characters), excluding the
+   * line terminator.
+   *
+   * @param in   the data to be uuencoded
+   * @return     a uuencoded data.
+   */
+  static QCString uuencode( const QByteArray& in );
+
+  /**
+   * @overload
+   *
+   * Same as the above functions except it accepts
+   * a null terminated string instead an array.
+   *
+   * @param str   the string to be uuencoded.
+   * @return      the encoded string.
+   */
+  static QCString uuencode( const QCString& str );
+
+  /**
+   * Encodes the given data using the uuencode algorithm.
+   *
+   * Use this function if you want the result of the encoding
+   * to be placed in another array and cut down the number of
+   * copy operation that have to be performed in the process.
+   * This is the preffered method for encoding binary data.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in   the data to be uuencoded.
+   * @param out  the container for the uudecoded data.
+   */
+  static void uuencode( const QByteArray& in, QByteArray& out );
+
+  /**
+   * Decodes the given data using the uuencode algorithm.
+   *
+   * Any 'begin' and 'end' lines like those generated by
+   * the utilities in unix and unix-like OS will be
+   * automatically ignored.
+   *
+   * @param in   the data uuencoded data to be decoded.
+   * @return     a decoded string.
+   */
+  static QCString uudecode( const QByteArray& in );
+
+  /**
+   * @overload
+   *
+   * Same as the above functions except it accepts
+   * a null terminated string instead an array.
+   *
+   * @param str   the string to be decoded.
+   * @return      a uudecoded string.
+   */
+  static QCString uudecode( const QCString& str );
+
+  /**
+   * Decodes the given data using the uudecode algorithm.
+   *
+   * Use this function if you want the result of the decoding
+   * to be placed in another array which cuts down the number
+   * of copy operation that have to be performed in the process.
+   * This is the preferred method for decoding binary data.
+   *
+   * Any 'begin' and 'end' lines like those generated by
+   * the utilities in unix and unix-like OS will be
+   * automatically ignored.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in   the uuencoded-data to be decoded.
+   * @param out  the container for the uudecoded data.
+   */
+  static void uudecode( const QByteArray& in, QByteArray& out );
+
+
+  /**
+   * Encodes the given data using the base64 algorithm.
+   *
+   * The boolean argument determines if the encoded data is
+   * going to be restricted to 76 characters or less per line
+   * as specified by RFC 2045.  If @p insertLFs is true, then
+   * there will be 76 characters or less per line.
+   *
+   * @param in         the data to be encoded.
+   * @param insertLFs  limit the number of characters per line.
+   *
+   * @return           a base64 encoded string.
+   */
+  static QCString base64Encode( const QByteArray& in, bool insertLFs = false);
+
+  /**
+   * @overload
+   *
+   * Same as the above functions except it accepts
+   * a null terminated string instead an array.
+   *
+   * @param str       the string to be encoded.
+   * @param insertLFs limit the number of characters per line.
+   * @return          the decoded string.
+   */
+  static QCString base64Encode( const QCString& str, bool insertLFs = false );
+
+  /**
+   * Encodes the given data using the base64 algorithm.
+   *
+   * Use this function if you want the result of the encoding
+   * to be placed in another array which cuts down the number
+   * of copy operation that have to be performed in the process.
+   * This is also the preferred method for encoding binary data.
+   *
+   * The boolean argument determines if the encoded data is going
+   * to be restricted to 76 characters or less per line as specified
+   * by RFC 2045.  If @p insertLFs is true, then there will be 76
+   * characters or less per line.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in        the data to be encoded using base64.
+   * @param out       the container for the encoded data.
+   * @param insertLFs limit the number of characters per line.
+   */
+  static void base64Encode( const QByteArray& in, QByteArray& out,
+                            bool insertLFs = false );
+
+  /**
+   * Decodes the given data that was encoded using the
+   * base64 algorithm.
+   *
+   * @param in   the base64-encoded data to be decoded.
+   * @return     the decoded data.
+   */
+  static QCString base64Decode( const QByteArray& in );
+
+  /**
+   * @overload
+   *
+   * Same as the above functions except it accepts
+   * a null terminated string instead an array.
+   *
+   * @param str  the base64-encoded string.
+   * @return     the decoded string.
+   */
+  static QCString base64Decode( const QCString& str );
+
+  /**
+   * Decodes the given data that was encoded with the base64
+   * algorithm.
+   *
+   * Use this function if you want the result of the decoding
+   * to be placed in another array which cuts down the number
+   * of copy operation that have to be performed in the process.
+   * This is also the preferred method for decoding an encoded
+   * binary data.
+   *
+   * NOTE: the output array is first reset and then resized
+   * appropriately before use, hence, all data stored in the
+   * output array will be lost.
+   *
+   * @param in   the encoded data to be decoded.
+   * @param out  the container for the decoded data.
+   */
+  static void base64Decode( const QByteArray& in, QByteArray& out );
+
+
+private:
+  QCodecs();
+
+private:
+  static const char UUEncMap[64];
+  static const char UUDecMap[128];
+  static const char Base64EncMap[64];
+  static const char Base64DecMap[128];
+  static const char hexChars[16];
+  static const unsigned int maxQPLineLength;
+};
+
+class QMD5Private;
+/**
+ * Provides an easy to use C++ implementation of RSA's
+ * MD5 algorithm.
+ *
+ * The default constructor is designed to provide much the same
+ * functionality as the most commonly used C-implementation, while
+ * the other three constructors are meant to further simplify the
+ * process of obtaining a digest by calculating the result in a
+ * single step.
+ *
+ * QMD5 is state-based, that means you can add new contents with
+ * update() as long as you didn't request the digest value yet.
+ * After the digest value was requested, the object is "finalized"
+ * and you have to call reset() to be able to do another calculation
+ * with it.  The reason for this behaviour is that upon requesting
+ * the message digest QMD5 has to pad the received contents up to a
+ * 64 byte boundary to calculate its value. After this operation it
+ * is not possible to resume consuming data.
+ *
+ * @sect Usage:
+ *
+ * A common usage of this class:
+ *
+ * <PRE>
+ *  const char* test1;
+ *  QMD5::Digest rawResult;
+ *
+ *  test1 = "This is a simple test.";
+ *  QMD5 context (test1);
+ *  cout << "Hex Digest output: " << context.hexDigest().data() << endl;
+ * </PRE>
+ *
+ * To cut down on the unnecessary overhead of creating multiple QMD5
+ * objects, you can simply invoke @ref reset() to reuse the same object
+ * in making another calculation:
+ *
+ * <PRE>
+ *  context.reset ();
+ *  context.update ("TWO");
+ *  context.update ("THREE");
+ *  cout << "Hex Digest output: " << context.hexDigest().data() << endl;
+ * </PRE>
+ *
+ * @short An adapted C++ implementation of RSA Data Securities MD5 algorithm.
+ * @author Dirk Mueller <mueller@kde.org>, Dawit Alemayehu <adawit@kde.org>
+ */
+
+class QMD5
+{
+public:
+
+  typedef unsigned char Digest[16];
+
+  QMD5();
+
+  /**
+   * Constructor that updates the digest for the given string.
+   *
+   * @param in   C string or binary data
+   * @param len  if negative, calculates the length by using
+   *             strlen on the first parameter, otherwise
+   *             it trusts the given length (does not stop on NUL byte).
+   */
+  QMD5(const char* in, int len = -1);
+
+  /**
+   * @overload
+   *
+   * Same as above except it accepts a QByteArray as its argument.
+   */
+  QMD5(const QByteArray& a );
+
+  /**
+   * @overload
+   *
+   * Same as above except it accepts a QByteArray as its argument.
+   */
+  QMD5(const QCString& a );
+
+  /**
+   * Updates the message to be digested. Be sure to add all data
+   * before you read the digest. After reading the digest, you
+   * can <b>not</b> add more data!
+   *
+   * @param in     message to be added to digest
+   * @param len    the length of the given message.
+   */
+  void update(const char* in, int len = -1) { update(reinterpret_cast<const unsigned char*>(in), len); }
+
+  /**
+   * @overload
+   */
+  void update(const unsigned char* in, int len = -1);
+
+  /**
+   * @overload
+   *
+   * @param in     message to be added to the digest (QByteArray).
+   */
+  void update(const QByteArray& in );
+
+  /**
+   * @overload
+   *
+   * @param in     message to be added to the digest (QByteArray).
+   */
+  void update(const QCString& in );
+
+  /**
+   * @overload
+   *
+   * reads the data from an I/O device, i.e. from a file (QFile).
+   *
+   * NOTE that the file must be open for reading.
+   *
+   * @param file       a pointer to FILE as returned by calls like f{d,re}open
+   *
+   * @returns false if an error occured during reading.
+   */
+  bool update(QIODevice& file);
+
+  /**
+   * Calling this function will reset the calculated message digest.
+   * Use this method to perform another message digest calculation
+   * without recreating the QMD5 object.
+   */
+  void reset();
+
+  /**
+   * @return the raw representation of the digest
+   */
+  const Digest& rawDigest ();
+
+  /**
+   * Fills the given array with the binary representation of the
+   * message digest.
+   *
+   * Use this method if you do not want to worry about making
+   * copy of the digest once you obtain it.
+   *
+   * @param bin an array of 16 characters ( char[16] )
+   */
+  void rawDigest( QMD5::Digest& bin );
+
+  /**
+   * Returns the value of the calculated message digest in
+   * a hexadecimal representation.
+   */
+  QCString hexDigest ();
+
+  /**
+   * @overload
+   */
+  void hexDigest(QCString&);
+
+  /**
+   * Returns the value of the calculated message digest in
+   * a base64-encoded representation.
+   */
+  QCString base64Digest ();
+
+  /**
+   * returns true if the calculated digest for the given
+   * message matches the given one.
+   */
+  bool verify( const QMD5::Digest& digest);
+
+  /**
+   * @overload
+   */
+  bool verify(const QCString&);
+
+protected:
+  /**
+   *  Performs the real update work.  Note
+   *  that length is implied to be 64.
+   */
+  void transform( const unsigned char buffer[64] );
+
+  /**
+   * finalizes the digest
+   */
+  void finalize();
+
+private:
+  QMD5(const QMD5& u);
+  QMD5& operator=(const QMD5& md);
+
+  void init();
+  void encode( unsigned char* output, Q_UINT32 *in, Q_UINT32 len );
+  void decode( Q_UINT32 *output, const unsigned char* in, Q_UINT32 len );
+
+  Q_UINT32 rotate_left( Q_UINT32 x, Q_UINT32 n );
+  Q_UINT32 F( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
+  Q_UINT32 G( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
+  Q_UINT32 H( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
+  Q_UINT32 I( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
+  void FF( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
+               Q_UINT32  s, Q_UINT32 ac );
+  void GG( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
+                Q_UINT32 s, Q_UINT32 ac );
+  void HH( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
+                Q_UINT32 s, Q_UINT32 ac );
+  void II( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
+             Q_UINT32 s, Q_UINT32 ac );
+
+private:
+  Q_UINT32 m_state[4];
+  Q_UINT32 m_count[2];
+  Q_UINT8 m_buffer[64];
+  Digest m_digest;
+  bool m_finalized;
+
+  QMD5Private* d;
+};
+#endif
diff -Naur mythtv-0.18-old/libs/libmyth/themedmenu.cpp mythtv-0.18-new/libs/libmyth/themedmenu.cpp
--- mythtv-0.18-old/libs/libmyth/themedmenu.cpp	2005-03-25 09:13:08.000000000 -0800
+++ mythtv-0.18-new/libs/libmyth/themedmenu.cpp	2005-05-14 06:54:35.227658175 -0700
@@ -192,6 +192,7 @@
     int exitModifier;
 
     bool spreadbuttons;
+    bool buttoncenter;
 
     QMap<QString, QPixmap> titleIcons;
     QPixmap *curTitle;
@@ -201,6 +202,7 @@
     bool drawTitle;
 
     QPixmap backgroundPixmap;
+    QPixmap* buttonBackground;
 
     bool ignorekeys;
 
@@ -243,6 +245,7 @@
     buttonactive = NULL;
     uparrow = NULL;
     downarrow = NULL;
+    buttonBackground = NULL;
 
     ignorekeys = false;
 }
@@ -259,6 +262,8 @@
         delete uparrow;
     if (downarrow)
         delete downarrow;
+    if (buttonBackground)
+        delete buttonBackground;
 
     QMap<QString, ButtonIcon>::Iterator it;
     for (it = allButtonIcons.begin(); it != allButtonIcons.end(); ++it)
@@ -292,7 +297,7 @@
     QString path;
 
     bool hasarea = false;
-
+    buttoncenter = true;
     spreadbuttons = true;
     maxColumns = 20;        // Arbitrary number
     visiblerowlimit = 6;    // the old default
@@ -323,6 +328,12 @@
 
                 buttonArea = tmpArea;
                 hasarea = true;
+                if (info.hasAttribute( "background" ))
+                {
+                    cerr << "Loading " << info.attribute( "background" ) << endl;
+                    QString bPath = dir + info.attribute( "background" );
+                    buttonBackground = gContext->LoadScalePixmap(bPath);
+                }
             }
             else if (info.tagName() == "buttonspread")
             {
@@ -330,6 +341,12 @@
                 if (val == "no")
                     spreadbuttons = false;
             }
+            else if (info.tagName() == "buttoncenter")
+            {
+                QString val = getFirstText(info);
+                if (val == "no")
+                    buttoncenter = false;
+            }
             else if (info.tagName() == "balancerows")
             {
                 QString val = getFirstText(info);
@@ -1732,7 +1749,10 @@
     if (!spreadbuttons)
     {
         yspacing = 0;
-        ystart = (buttonArea.height() - buttonnormal->height() * rows) / 2;
+        if (buttoncenter)
+        {
+            ystart = (buttonArea.height() - buttonnormal->height() * rows) / 2;
+        }
     }
 
     int row = 1;
@@ -1861,6 +1881,10 @@
     paintLogo(&tmp);
     paintTitle(&tmp);
 
+    if (buttonBackground)
+    {
+        tmp.drawPixmap(buttonArea.topLeft(), *buttonBackground);
+    }
     ThemedButton *store = activebutton;
     activebutton = NULL;
     
diff -Naur mythtv-0.18-old/libs/libmyth/uitypes.h mythtv-0.18-new/libs/libmyth/uitypes.h
--- mythtv-0.18-old/libs/libmyth/uitypes.h	2004-12-29 13:00:45.000000000 -0800
+++ mythtv-0.18-new/libs/libmyth/uitypes.h	2005-05-14 06:54:35.228658062 -0700
@@ -346,7 +346,11 @@
     enum ItemArrows  { ARROW_NONE, ARROW_LEFT, ARROW_RIGHT, ARROW_BOTH };
 
     void SetCount(int cnt) { m_count = cnt;
-                             m_selheight = (int)(m_area.height() / m_count); }
+                             if (m_count)
+                                 m_selheight = (int)(m_area.height() / m_count);
+                             else
+                                 m_selheight = 0;
+                         }
 
     void SetItemText(int, int, QString);
     void SetItemText(int, QString);
diff -Naur mythtv-0.18-old/libs/libmythmpeg2/libmythmpeg2.pro mythtv-0.18-new/libs/libmythmpeg2/libmythmpeg2.pro
--- mythtv-0.18-old/libs/libmythmpeg2/libmythmpeg2.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmythmpeg2/libmythmpeg2.pro	2005-05-14 06:54:35.228658062 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0 
+VERSION = 0.18.1 
 
 QMAKE_CFLAGS_RELEASE += -fPIC -fno-common
 QMAKE_CFLAGS_DEBUG += -fPIC -fno-common
diff -Naur mythtv-0.18-old/libs/libmythsamplerate/libmythsamplerate.pro mythtv-0.18-new/libs/libmythsamplerate/libmythsamplerate.pro
--- mythtv-0.18-old/libs/libmythsamplerate/libmythsamplerate.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmythsamplerate/libmythsamplerate.pro	2005-05-14 06:54:35.229657948 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0 
+VERSION = 0.18.1 
 
 INCLUDEPATH += ../../ 
 
diff -Naur mythtv-0.18-old/libs/libmythsoundtouch/libmythsoundtouch.pro mythtv-0.18-new/libs/libmythsoundtouch/libmythsoundtouch.pro
--- mythtv-0.18-old/libs/libmythsoundtouch/libmythsoundtouch.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmythsoundtouch/libmythsoundtouch.pro	2005-05-14 06:54:35.229657948 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0 
+VERSION = 0.18.1 
 
 INCLUDEPATH += ../../ 
 
diff -Naur mythtv-0.18-old/libs/libmythtv/avformatdecoder.cpp mythtv-0.18-new/libs/libmythtv/avformatdecoder.cpp
--- mythtv-0.18-old/libs/libmythtv/avformatdecoder.cpp	2005-03-27 21:01:39.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/avformatdecoder.cpp	2005-05-14 06:54:35.230657834 -0700
@@ -253,6 +253,9 @@
 void AvFormatDecoder::Reset(void)
 {
     SeekReset();
+#if 0
+    // mpegts.c already clears the stream, so this code results in
+    // silence on live tv with mpeg-ts recordings.
 
     // Clear out the existing mpeg streams
     // so we can get a clean set from the 
@@ -267,6 +270,7 @@
             av_remove_stream(ic, st->id);
         }
     }
+#endif
 
     m_positionMap.clear();
     framesPlayed = 0;
diff -Naur mythtv-0.18-old/libs/libmythtv/datadirect.cpp mythtv-0.18-new/libs/libmythtv/datadirect.cpp
--- mythtv-0.18-old/libs/libmythtv/datadirect.cpp	2005-04-04 09:47:37.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/datadirect.cpp	2005-05-14 06:54:35.231657721 -0700
@@ -8,6 +8,8 @@
 #include <qstring.h>
 #include <cerrno>
 
+const QString DataDirectURLS[] = { "http://datadirect.webservices.zap2it.com/tvlistings/xtvdService",
+                                   "http://webservices.technovera.tmsdatadirect.com/technovera/tvlistings/xtvdService"};
 // XXX Program duration should be stored as seconds, not as a QTime.
 //     limited to 24 hours this way.
 
@@ -444,7 +446,8 @@
     FILE *ret = NULL;
     if (inputfilename.isNull())
     {
-        QString ddurl("http://datadirect.webservices.zap2it.com/tvlistings/xtvdService");
+        //QString ddurl("http://datadirect.webservices.zap2it.com/tvlistings/xtvdService");
+        QString ddurl(DataDirectURLS[source]);
 
         if (plineupsOnly) 
         {
diff -Naur mythtv-0.18-old/libs/libmythtv/datadirect.h mythtv-0.18-new/libs/libmythtv/datadirect.h
--- mythtv-0.18-old/libs/libmythtv/datadirect.h	2005-01-27 23:33:46.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/datadirect.h	2005-05-14 06:54:35.232657607 -0700
@@ -7,6 +7,8 @@
 #include <qsqldatabase.h>
 #include <qsqlquery.h>
 
+enum DD_PROVIDERS { DD_ZAP2IT, DD_LXM };
+
 class DataDirectProcessor;
 
 class DataDirectStation 
@@ -220,8 +222,9 @@
 class DataDirectProcessor
 {
   public:
-    DataDirectProcessor() 
+    DataDirectProcessor( int _source = DD_ZAP2IT ) 
     {
+        source = _source;
         stations.clear();
         lineups.clear();
         lineupmaps.clear();
@@ -235,10 +238,12 @@
     QString getUserID() const { return userid; }
     QString getPassword() const { return password; }
     QString getLineup() const { return selectedlineupid; }
+    int getSource() { return source; }
 
     void setUserID(QString uid) { userid = uid; };
     void setPassword(QString pwd) { password = pwd; };
     void setLineup(QString lid) { selectedlineupid = lid; };
+    void setSource(int _source) { source = _source; }
 
     QDateTime getActualListingsFrom() const { return actuallistingsfrom; }
     QDateTime getActualListingsTo() const { return actuallistingsto; }
@@ -268,6 +273,8 @@
     QValueList<DataDirectLineupMap> lineupmaps;
      
   private:
+    int source;
+
     QString selectedlineupid;
     QString userid;
     QString password;
diff -Naur mythtv-0.18-old/libs/libmythtv/firewirechannel.cpp mythtv-0.18-new/libs/libmythtv/firewirechannel.cpp
--- mythtv-0.18-old/libs/libmythtv/firewirechannel.cpp	2005-02-01 23:11:10.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/firewirechannel.cpp	2005-05-14 06:54:35.232657607 -0700
@@ -12,23 +12,69 @@
 class TVRec;
 
 
-FirewireChannel::FirewireChannel(TVRec *parent): ChannelBase(parent) {
+FirewireChannel::FirewireChannel(firewire_options_t firewire_opts, TVRec *parent): 
+    ChannelBase(parent),fw_opts(firewire_opts) {
+	
+    isopen = false;
     capchannels = 1;
+    fwhandle = NULL;
     channelnames[0] = "MPEG2TS";
+
+    if(externalChanger[currentcapchannel].isEmpty()) {
+
+       if(fw_opts.model == "DCT-6200") {
+          if((fwhandle = raw1394_new_handle_on_port(fw_opts.port)) == NULL) {
+              VERBOSE(VB_IMPORTANT,QString("FireWireChannel: unable to get handle for port: %1").arg(fw_opts.port));
+              return;
+          }
+
+          VERBOSE(VB_GENERAL,QString("FireWireChannel: allocated raw1394 handle for port %1").arg(fw_opts.port));
+          isopen = true;
+       } else {
+          VERBOSE(VB_IMPORTANT,QString("FireWireChannel: internal channel changer only supported by DCT-6200 models"));
+       }
+    }
 }
 
 FirewireChannel::~FirewireChannel(void)
-{   
+{
+
+    if(isopen) {
+        VERBOSE(VB_GENERAL,QString("FireWireChannel: releasing raw1394 handle"));
+        raw1394_destroy_handle(fwhandle);
+    }
+
 }
 
 bool FirewireChannel::SetChannelByString(const QString &chan) {
 
+     int dig[3];
+     int channel = chan.toInt();
+     quadlet_t cmd[2];
 
      inputChannel[currentcapchannel] = chan;
      curchannelname = chan;
 
      if (externalChanger[currentcapchannel].isEmpty()) {
-         VERBOSE(VB_IMPORTANT,QString("FireWire: external channel changer only supported at this time.")); 
+         dig[2] = channel % 10;
+         dig[1] = (channel % 100) / 10;
+         dig[0] = (channel % 1000) / 100;
+
+         if(isopen && fw_opts.model == "DCT-6200") {
+            VERBOSE(VB_GENERAL,QString("FireWireChannel: channel:%1%2%3 cmds: 0x%4, 0x%5, 0x%6").
+              arg(dig[0]).arg(dig[1]).arg(dig[2]).arg(DCT6200_CMD0 | dig[0], 0, 16).
+              arg(DCT6200_CMD0 | dig[1], 0, 16).
+              arg(DCT6200_CMD0 | dig[2], 0, 16));
+            for(int i = 0;i < 3 ;i++) {
+                cmd[0] = DCT6200_CMD0 | dig[i];
+                cmd[1] = 0x0;
+     
+                avc1394_transaction_block(fwhandle, fw_opts.node, cmd, 2, 1);
+                usleep(500000);
+            }
+         } else {
+            VERBOSE(VB_IMPORTANT,QString("FireWireChannel: internal channel changer only supported by DCT-6200 models"));
+         }
      } else if(!ChangeExternalChannel(chan)) {
          return false;
      }
diff -Naur mythtv-0.18-old/libs/libmythtv/firewirechannel.h mythtv-0.18-new/libs/libmythtv/firewirechannel.h
--- mythtv-0.18-old/libs/libmythtv/firewirechannel.h	2005-02-01 23:11:10.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/firewirechannel.h	2005-05-14 06:54:35.233657494 -0700
@@ -11,13 +11,24 @@
 #include <qstring.h>
 #include "tv_rec.h"
 #include "channelbase.h"
+#include <libavc1394/avc1394.h>
 
 using namespace std;
 
+// 6200 defines for channel changes, taken from contrib/6200ch.c
+#define AVC1394_SUBUNIT_TYPE_6200 	(9 << 19)  /* uses a reserved subunit type */ 
+#define AVC1394_6200_COMMAND_CHANNEL 	0x00007C00 /* 6200 subunit command */
+#define AVC1394_6200_OPERAND_SET 	0x00000020 /* 6200 subunit command operand */
+
+#define DCT6200_CMD0 AVC1394_CTYPE_CONTROL | AVC1394_SUBUNIT_TYPE_6200 | \
+        AVC1394_SUBUNIT_ID_0 | AVC1394_6200_COMMAND_CHANNEL | \
+        AVC1394_6200_OPERAND_SET
+
+
 class FirewireChannel : public ChannelBase
 {
  public:
-    FirewireChannel(TVRec *parent);
+    FirewireChannel(firewire_options_t firewire_opts, TVRec *parent);
     ~FirewireChannel(void);
 
     bool SetChannelByString(const QString &chan);
@@ -27,7 +38,11 @@
     void SwitchToInput(int newcapchannel, bool setstarting)
                       { (void)newcapchannel; (void)setstarting; }
     void SetExternalChanger(void);
-
+private:
+    firewire_options_t fw_opts;
+    nodeid_t fwnode;
+    raw1394handle_t fwhandle;
+    bool isopen;
 };
 
 #endif
diff -Naur mythtv-0.18-old/libs/libmythtv/firewirerecorder.cpp mythtv-0.18-new/libs/libmythtv/firewirerecorder.cpp
--- mythtv-0.18-old/libs/libmythtv/firewirerecorder.cpp	2005-03-11 11:18:51.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/firewirerecorder.cpp	2005-05-14 06:54:35.233657494 -0700
@@ -23,7 +23,13 @@
      if(dropped) {
          VERBOSE(VB_GENERAL,QString("Firewire: %1 packet(s) dropped.").arg(dropped));
      }
-     fw->ProcessTSPacket(tspacket,len);
+
+     if(tspacket[0] == SYNC_BYTE) {
+         fw->ProcessTSPacket(tspacket,len);
+     } else {
+        VERBOSE(VB_GENERAL,QString("Firewire: out of sync mpeg2ts packet"));
+     }
+
      return 1;
 }
 
diff -Naur mythtv-0.18-old/libs/libmythtv/guidegrid.cpp mythtv-0.18-new/libs/libmythtv/guidegrid.cpp
--- mythtv-0.18-old/libs/libmythtv/guidegrid.cpp	2005-02-22 21:04:36.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/guidegrid.cpp	2005-05-14 06:54:35.234657380 -0700
@@ -324,6 +324,22 @@
     }
     else
     {
+        // We want to handle jump to channel before everything else
+        // The reason is because the number keys could be mapped to
+        // other things. If this is the case, then the jump to channel
+        // will not work correctly.
+        if (jumpToChannelEnabled) 
+        {
+            int digit;
+            if (jumpToChannelGetInputDigit(actions, digit)) 
+            {
+                jumpToChannelDigitPress(digit);
+                // Set handled = true here so that it won't process any
+                // more actions.
+                handled = true;
+            }
+        }        
+	      
         for (unsigned int i = 0; i < actions.size() && !handled; i++)
         {
             QString action = actions[i];
@@ -349,9 +365,6 @@
                 dayLeft();
             else if (action == "DAYRIGHT")
                 dayRight();
-            else if (jumpToChannelEnabled &&
-                     ((action[0] >= '0') && (action[0] <= '9')))
-                jumpToChannelDigitPress(action.toInt());
             else if (jumpToChannelEnabled && jumpToChannelActive &&
                      (action == "ESCAPE"))
                 jumpToChannelCancel();
@@ -1760,9 +1773,10 @@
 {
     jumpToChannel /= 10;
     
-    if (jumpToChannel == 0) {
+    if (jumpToChannel == 0) 
         jumpToChannelCancel();
-    }
+    else 
+        jumpToChannelShowSelection();
 }
 
 void GuideGrid::jumpToChannelShowSelection()
@@ -1819,3 +1833,20 @@
     jumpToChannelCommit();
 }
 
+// function returns true if it is able to find a mapping to a digit and false
+// otherwise.
+bool GuideGrid::jumpToChannelGetInputDigit(QStringList &actions, int &digit)
+{
+    for (unsigned int i = 0; i < actions.size(); ++i) 
+    {
+        QString action = actions[i];
+        if (action[0] >= '0' && action[0] <= '9') 
+        {
+            digit = action.toInt();
+            return true;
+        }
+    }
+    
+    // There were no actions that resolved to a digit
+    return false;
+}
diff -Naur mythtv-0.18-old/libs/libmythtv/guidegrid.h mythtv-0.18-new/libs/libmythtv/guidegrid.h
--- mythtv-0.18-old/libs/libmythtv/guidegrid.h	2005-02-22 21:04:36.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/guidegrid.h	2005-05-14 06:54:35.235657266 -0700
@@ -175,6 +175,7 @@
     void jumpToChannelShowSelection();
     void jumpToChannelDeleteLastDigit();
     void jumpToChannelDigitPress(int);
+    bool jumpToChannelGetInputDigit(QStringList & actions, int & digit);
     int jumpToChannel;
     int jumpToChannelPreviousStartChannel;
     int jumpToChannelPreviousRow;
diff -Naur mythtv-0.18-old/libs/libmythtv/libmythtv.pro mythtv-0.18-new/libs/libmythtv/libmythtv.pro
--- mythtv-0.18-old/libs/libmythtv/libmythtv.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/libmythtv.pro	2005-05-14 06:54:35.235657266 -0700
@@ -7,7 +7,7 @@
 target.path = $${PREFIX}/lib
 INSTALLS = target
 
-VERSION = 0.18.0
+VERSION = 0.18.1
 
 INCLUDEPATH += ../..
 INCLUDEPATH += ../libmyth ../ ./dvbdev/ ./mpeg/ ../libavcodec ../libmythmpeg2
diff -Naur mythtv-0.18-old/libs/libmythtv/osdtypes.cpp mythtv-0.18-new/libs/libmythtv/osdtypes.cpp
--- mythtv-0.18-old/libs/libmythtv/osdtypes.cpp	2005-03-31 18:38:31.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/osdtypes.cpp	2005-05-14 06:54:35.237657039 -0700
@@ -446,6 +446,7 @@
     m_altfont = NULL;
     
     m_displaysize = displayrect;
+    m_screensize = displayrect;
     m_multiline = false;
     m_centered = false;
     m_right = false;
@@ -462,6 +463,7 @@
            : OSDType(other.m_name)
 {
     m_displaysize = other.m_displaysize;
+    m_screensize = other.m_screensize;
     m_message = other.m_message;
     m_default_msg = other.m_default_msg;
     m_font = other.m_font;
@@ -500,12 +502,12 @@
 
 void OSDTypeText::Reinit(float wchange, float hchange)
 {
-    int width = (int)(m_displaysize.width() * wchange);
-    int height = (int)(m_displaysize.height() * hchange);
-    int x = (int)(m_displaysize.x() * wchange);
-    int y = (int)(m_displaysize.y() * hchange);
+    int width = (int)(m_screensize.width() * wchange);
+    int height = (int)(m_screensize.height() * hchange);
+    int x = (int)(m_screensize.x() * wchange);
+    int y = (int)(m_screensize.y() * hchange);
 
-    m_displaysize = QRect(x, y, width, height);
+    m_displaysize = m_screensize = QRect(x, y, width, height);
 }
 
 void OSDTypeText::Draw(OSDSurface *surface, int fade, int maxfade, int xoff, 
@@ -598,6 +600,7 @@
     {
         if (!m_scrollinit)
         {
+            m_displaysize = m_screensize;
             if (m_scrollx < 0)
             {
                 int numspaces = m_displaysize.width() / m_font->SpaceWidth();
@@ -1498,12 +1501,16 @@
 {
     if (m_curposition > m_offset)
         m_curposition--;
+    else if (m_curposition == m_offset)
+        m_curposition = m_numpositions - 1;
 }
 
 void OSDTypePositionIndicator::PositionDown(void)
 {
     if (m_curposition < m_numpositions - 1)
         m_curposition++;
+    else if (m_curposition == m_numpositions - 1) 
+        m_curposition = m_offset;
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur mythtv-0.18-old/libs/libmythtv/osdtypes.h mythtv-0.18-new/libs/libmythtv/osdtypes.h
--- mythtv-0.18-old/libs/libmythtv/osdtypes.h	2005-03-31 18:38:31.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/osdtypes.h	2005-05-14 06:54:35.237657039 -0700
@@ -184,6 +184,7 @@
                     int fade, int maxfade, int xoff, int yoff);
 
     QRect m_displaysize;
+    QRect m_screensize;
     QString m_message;
     QString m_default_msg;
 
diff -Naur mythtv-0.18-old/libs/libmythtv/proglist.cpp mythtv-0.18-new/libs/libmythtv/proglist.cpp
--- mythtv-0.18-old/libs/libmythtv/proglist.cpp	2005-04-09 01:14:28.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/proglist.cpp	2005-05-14 06:54:35.239656812 -0700
@@ -299,12 +299,12 @@
     QRect r = e->rect();
     QPainter p(this);
  
-    if (updateAll || r.intersects(viewRect))
-        updateView(&p);
     if (updateAll || r.intersects(listRect))
         updateList(&p);
     if (updateAll || r.intersects(infoRect))
         updateInfo(&p);
+    if (updateAll || r.intersects(viewRect))
+        updateView(&p);
 
     updateAll = false;
 }
diff -Naur mythtv-0.18-old/libs/libmythtv/tv_play.cpp mythtv-0.18-new/libs/libmythtv/tv_play.cpp
--- mythtv-0.18-old/libs/libmythtv/tv_play.cpp	2005-04-13 20:43:05.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/tv_play.cpp	2005-05-14 06:54:35.241656585 -0700
@@ -4093,32 +4093,32 @@
     item = new OSDGenericTree(treeMenu, tr("Manual Zoom Mode"), 
                              "TOGGLEMANUALZOOM");
 
-    int speedX10 = (int)(ceil(normal_speed * 10));
+    int speedX100 = (int)(round(normal_speed * 100));
     item = new OSDGenericTree(treeMenu, tr("Adjust Time Stretch"), "TOGGLESTRETCH");
     subitem = new OSDGenericTree(item, tr("Adjust"), "TOGGLESTRETCH");
     subitem = new OSDGenericTree(item, tr("0.5X"), "TOGGLESTRETCH0.5",
-                                 (speedX10 == 5) ? 1 : 0, NULL,
+                                 (speedX100 == 50) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("0.9X"), "TOGGLESTRETCH0.9",
-                                 (speedX10 == 9) ? 1 : 0, NULL,
+                                 (speedX100 == 90) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.0X"), "TOGGLESTRETCH1.0",
-                                 (speedX10 == 10) ? 1 : 0, NULL,
+                                 (speedX100 == 100) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.1X"), "TOGGLESTRETCH1.1",
-                                 (speedX10 == 11) ? 1 : 0, NULL,
+                                 (speedX100 == 110) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.2X"), "TOGGLESTRETCH1.2",
-                                 (speedX10 == 12) ? 1 : 0, NULL,
+                                 (speedX100 == 120) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.3X"), "TOGGLESTRETCH1.3",
-                                 (speedX10 == 13) ? 1 : 0, NULL,
+                                 (speedX100 == 130) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.4X"), "TOGGLESTRETCH1.4",
-                                 (speedX10 == 14) ? 1 : 0, NULL,
+                                 (speedX100 == 140) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
     subitem = new OSDGenericTree(item, tr("1.5X"), "TOGGLESTRETCH1.5",
-                                 (speedX10 == 15) ? 1 : 0, NULL,
+                                 (speedX100 == 150) ? 1 : 0, NULL,
                                  "STRETCHGROUP");
 
     // add sleep items to menu
diff -Naur mythtv-0.18-old/libs/libmythtv/tv_rec.cpp mythtv-0.18-new/libs/libmythtv/tv_rec.cpp
--- mythtv-0.18-old/libs/libmythtv/tv_rec.cpp	2005-04-03 09:42:10.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/tv_rec.cpp	2005-05-14 06:54:35.243656358 -0700
@@ -126,7 +126,7 @@
     else if (cardtype == "FIREWIRE")
     {
 #ifdef USING_FIREWIRE
-        channel = new FirewireChannel(this);
+        channel = new FirewireChannel(firewire_options, this);
         channel->Open();
         if (inputname.isEmpty())
             channel->SetChannelByString(startchannel);
@@ -1034,7 +1034,6 @@
                   "channel.outputfilters, previouslyshown, originalairdate, stars "
                   "FROM program,channel,capturecard,cardinput "
                   "WHERE channel.channum = :CHANNAME "
-                  "AND channel.visible = 1 "
                   "AND starttime < :CURTIME AND endtime > :CURTIME AND "
                   "program.chanid = channel.chanid AND "
                   "channel.sourceid = cardinput.sourceid AND "
@@ -1627,6 +1626,7 @@
     QString wherepart = QString("cardinput.cardid = capturecard.cardid AND "
                                 "capturecard.cardid = \"%1\" AND "
                                 "capturecard.hostname = \"%2\" AND "
+                                "channel.visible = 1 AND "
                                 "cardinput.sourceid = channel.sourceid ")
                                 .arg(cardid)
                                 .arg(gContext->GetHostName());
diff -Naur mythtv-0.18-old/libs/libmythtv/videosource.cpp mythtv-0.18-new/libs/libmythtv/videosource.cpp
--- mythtv-0.18-old/libs/libmythtv/videosource.cpp	2005-04-13 15:58:08.000000000 -0700
+++ mythtv-0.18-new/libs/libmythtv/videosource.cpp	2005-05-14 06:54:35.244656244 -0700
@@ -226,20 +226,28 @@
 };
 
 void DataDirectLineupSelector::fillSelections(const QString &uid,
-                                              const QString &pwd) 
+                                              const QString &pwd,
+                                              int _source) 
 {
     if (uid.isEmpty() || pwd.isEmpty())
         return;
 
     qApp->processEvents();
 
-    QString waitMsg = tr("Fetching lineups from DataDirect service...");
+    //QString waitMsg = tr("Fetching lineups from DataDirect service...");
+    QString waitMsg;
+    if (_source == DD_ZAP2IT)
+
+        waitMsg = tr("Fetching lineups from DataDirect service...");
+    else
+        waitMsg = tr("Fetching lineups from the Myth Plus service...");
+
     VERBOSE(VB_GENERAL, waitMsg);
     MythProgressDialog pdlg(waitMsg, 2);
 
     clearSelections();
 
-    DataDirectProcessor ddp;
+    DataDirectProcessor ddp(_source);
     ddp.setUserID(uid);
     ddp.setPassword(pwd);
 
@@ -267,15 +275,18 @@
         (password->getValue() != lastloadedpassword)) 
     {
         lineupselector->fillSelections(userid->getValue(), 
-                                       password->getValue());
+                                       password->getValue(),
+                                       source);
         lastloadeduserid = userid->getValue();
         lastloadedpassword = password->getValue();
     }
 }
 
-DataDirect_config::DataDirect_config(const VideoSource& _parent)
+DataDirect_config::DataDirect_config(const VideoSource& _parent, int _source)
                  : parent(_parent) 
 {
+    cerr << "new DataDirect_config source == " << _source << endl;
+    source = _source;
     setUseLabel(false);
     setUseFrame(false);
 
@@ -297,7 +308,7 @@
 
 void DataDirect_config::fillDataDirectLineupSelector(void)
 {
-    lineupselector->fillSelections(userid->getValue(), password->getValue());
+    lineupselector->fillSelections(userid->getValue(), password->getValue(), source);
 }
 
 void RegionSelector::fillSelections() {
@@ -513,6 +524,9 @@
     addTarget("datadirect", new DataDirect_config(parent));
     grabber->addSelection("North America (DataDirect)", "datadirect");
 
+    addTarget("technovera", new DataDirect_config(parent, DD_LXM));
+    grabber->addSelection("LxM (United States)", "technovera");
+
     addTarget("tv_grab_de_tvtoday", new XMLTV_generic_config(parent, "tv_grab_de_tvtoday"));
     grabber->addSelection("Germany (tvtoday)", "tv_grab_de_tvtoday");
 
@@ -856,9 +870,10 @@
  	CCSetting(parent, "firewire_model") {
             setLabel(QObject::tr("Firewire Model"));
             addSelection(QObject::tr("Other"));
-            setHelpText(QObject::tr("Firewire Model is for future use in case "
-                                    "there is a need to model specific "
-                                    "workarounds.")); 
+            addSelection(QObject::tr("DCT-6200"));
+            setHelpText(QObject::tr("Select DCT-6200 to enable internal "
+                                    "channel-changing support, Other "
+                                    "for any other supported device.")); 
 
         }
 };
diff -Naur mythtv-0.18-old/libs/libmythtv/videosource.h mythtv-0.18-new/libs/libmythtv/videosource.h
--- mythtv-0.18-old/libs/libmythtv/videosource.h	2005-02-22 21:04:36.000000000 -0800
+++ mythtv-0.18-new/libs/libmythtv/videosource.h	2005-05-14 06:54:35.245656130 -0700
@@ -89,7 +89,7 @@
    };
 
  public slots:
-    void fillSelections(const QString& uid, const QString& pwd);
+    void fillSelections(const QString& uid, const QString& pwd, int source);
 };
 
 class DataDirectButton: public ButtonSetting, public TransientStorage {
@@ -106,7 +106,7 @@
 class DataDirect_config: public VerticalConfigurationGroup {
     Q_OBJECT
 public:
-    DataDirect_config(const VideoSource& _parent); 
+    DataDirect_config(const VideoSource& _parent, int _source = DD_ZAP2IT); 
 
     virtual void load();
 
@@ -123,6 +123,7 @@
     DataDirectButton* button;
     QString lastloadeduserid;
     QString lastloadedpassword;
+    int source;
 };
 
 class XMLTV_uk_config: public VerticalConfigurationGroup {
diff -Naur mythtv-0.18-old/libs/libmythui/libmythui.pro mythtv-0.18-new/libs/libmythui/libmythui.pro
--- mythtv-0.18-old/libs/libmythui/libmythui.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/libs/libmythui/libmythui.pro	2005-05-14 06:54:35.246656017 -0700
@@ -9,7 +9,7 @@
 INCLUDEPATH += ../../libs/libmyth
 INCLUDEPATH += ../..
 LIBS += -L../libmyth -lmyth-$$LIBVERSION
-VERSION = 0.18.0
+VERSION = 0.18.1
 
 # Input
 HEADERS  = mythmainwindow.h mythpainter.h mythimage.h
diff -Naur mythtv-0.18-old/programs/mythbackend/httpstatus.cpp mythtv-0.18-new/programs/mythbackend/httpstatus.cpp
--- mythtv-0.18-old/programs/mythbackend/httpstatus.cpp	2005-04-06 21:16:49.000000000 -0700
+++ mythtv-0.18-new/programs/mythbackend/httpstatus.cpp	2005-05-14 06:54:35.246656017 -0700
@@ -574,8 +574,8 @@
                             break;
 
                         default:
-                            statusColor = "class=\"jobqueued";
-                            jobColor = "class=\"jobqueued";
+                            statusColor = " class=\"jobqueued\"";
+                            jobColor = " class=\"jobqueued\"";
                             break;
                     }
 
diff -Naur mythtv-0.18-old/programs/mythbackend/scheduler.cpp mythtv-0.18-new/programs/mythbackend/scheduler.cpp
--- mythtv-0.18-old/programs/mythbackend/scheduler.cpp	2005-04-09 22:33:06.000000000 -0700
+++ mythtv-0.18-new/programs/mythbackend/scheduler.cpp	2005-05-14 06:54:35.248655790 -0700
@@ -1598,7 +1598,7 @@
         }
 
         VERBOSE(VB_SCHEDULE, QString(" |-- %1 results in %2 sec.")
-                .arg(result.size())
+                .arg(result.numRowsAffected())
                 .arg(((dbend.tv_sec  - dbstart.tv_sec) * 1000000 +
                       (dbend.tv_usec - dbstart.tv_usec)) / 1000000.0));
 
diff -Naur mythtv-0.18-old/programs/mythfilldatabase/filldata.cpp mythtv-0.18-new/programs/mythfilldatabase/filldata.cpp
--- mythtv-0.18-old/programs/mythfilldatabase/filldata.cpp	2005-04-13 15:58:08.000000000 -0700
+++ mythtv-0.18-new/programs/mythfilldatabase/filldata.cpp	2005-05-14 06:54:35.250655562 -0700
@@ -941,11 +941,12 @@
     //cerr << "Done...\n";
 }
 
-bool grabDDData(Source source, int poffset, QDate pdate) 
+bool grabDDData(Source source, int poffset, QDate pdate, int ddSource) 
 {
     ddprocessor.setLineup(source.lineupid);
     ddprocessor.setUserID(source.userid);
     ddprocessor.setPassword(source.password);
+    ddprocessor.setSource(ddSource);
 
     bool needtoretrieve = true;
 
@@ -990,7 +991,11 @@
             if (!quiet)
                 cout << "From : " << fromdatetime.toString() 
                      << " To : " << todatetime.toString() << " (UTC)\n";
-            ddprocessor.grabData(false, fromdatetime, todatetime);
+            if (!ddprocessor.grabData(false, fromdatetime, todatetime))
+            {
+                cout << "Encountered error in grabbing data..\n";
+                return false;
+            }
         }
 
         dddataretrieved = true;
@@ -2505,7 +2510,9 @@
     QString xmltv_grabber = source.xmltvgrabber;
 
     if (xmltv_grabber == "datadirect")
-        return grabDDData(source, offset, *qCurrentDate);
+        return grabDDData(source, offset, *qCurrentDate, DD_ZAP2IT);
+    else if (xmltv_grabber == "technovera")
+        return grabDDData(source, offset, *qCurrentDate, DD_LXM);
 
     char tempfilename[] = "/tmp/mythXXXXXX";
     if (mkstemp(tempfilename) == -1) {
@@ -2760,13 +2767,14 @@
             if (!grabData(*it, 0))
                 ++failures;
         }
-        else if (xmltv_grabber == "datadirect" && dd_grab_all)
+        else if ((xmltv_grabber == "datadirect" || xmltv_grabber == "technovera") && dd_grab_all)
         {
             QDate qCurrentDate = QDate::currentDate();
 
             grabData(*it, 0, &qCurrentDate);
         }
         else if (xmltv_grabber == "datadirect" ||
+                 xmltv_grabber == "technovera" ||
                  xmltv_grabber == "tv_grab_se_swedb" ||
                  xmltv_grabber == "tv_grab_no" ||
                  xmltv_grabber == "tv_grab_ee" ||
@@ -2805,6 +2813,8 @@
 
             if (xmltv_grabber == "datadirect")
                 maxday = 14;
+            else if (xmltv_grabber == "technovera")
+                maxday = 14;
             else if (xmltv_grabber == "tv_grab_no")
                 maxday = 7;
             else if (xmltv_grabber == "tv_grab_se_swedb")
diff -Naur mythtv-0.18-old/programs/mythfrontend/playbackbox.cpp mythtv-0.18-new/programs/mythfrontend/playbackbox.cpp
--- mythtv-0.18-old/programs/mythfrontend/playbackbox.cpp	2005-04-11 16:00:40.000000000 -0700
+++ mythtv-0.18-new/programs/mythfrontend/playbackbox.cpp	2005-05-14 06:54:35.252655335 -0700
@@ -159,6 +159,7 @@
     fullRect = QRect(0, 0, size().width(), size().height());
     listRect = QRect(0, 0, 0, 0);
     infoRect = QRect(0, 0, 0, 0);
+    groupRect = QRect(0, 0, 0, 0);
     usageRect = QRect(0, 0, 0, 0);
     videoRect = QRect(0, 0, 0, 0);
     curGroupRect = QRect(0, 0, 0, 0);
@@ -326,6 +327,8 @@
         infoRect = area;
     if (name.lower() == "video")
         videoRect = area;
+    if (name.lower() == "group_info")
+        groupRect = area;
     if (name.lower() == "usage")
         usageRect = area;
     if (name.lower() == "cur_group")
@@ -636,8 +639,13 @@
 void PlaybackBox::updateInfo(QPainter *p)
 {
     QRect pr = infoRect;
-    QPixmap pix(pr.size());
+
     bool updateGroup = (inTitle && haveGroupInfoSet);
+    if (updateGroup)
+        pr = groupRect;
+
+    QPixmap pix(pr.size());
+
     pix.fill(this, pr.topLeft());
     
     if (titleList.count() > 1 && curitem && !updateGroup)
diff -Naur mythtv-0.18-old/programs/mythfrontend/playbackbox.h mythtv-0.18-new/programs/mythfrontend/playbackbox.h
--- mythtv-0.18-old/programs/mythfrontend/playbackbox.h	2005-03-13 10:06:42.000000000 -0800
+++ mythtv-0.18-new/programs/mythfrontend/playbackbox.h	2005-05-14 06:54:35.253655222 -0700
@@ -249,6 +249,7 @@
     QRect fullRect;
     QRect listRect;
     QRect infoRect;
+    QRect groupRect;
     QRect usageRect;
     QRect videoRect;
     QRect curGroupRect;
diff -Naur mythtv-0.18-old/settings.pro mythtv-0.18-new/settings.pro
--- mythtv-0.18-old/settings.pro	2005-04-09 17:47:09.000000000 -0700
+++ mythtv-0.18-new/settings.pro	2005-05-14 06:54:35.218659198 -0700
@@ -4,7 +4,7 @@
     PREFIX = /usr/local
 }
 
-LIBVERSION = 0.18
+LIBVERSION = 0.18.1
 
 # Die on the (common) case where OS X users inadvertently use Fink's
 # Qt/X11 install instead of Qt/Mac.
