diff -Naur libxvmc-20050514-old/driDrawable.c libxvmc-20050514-new/driDrawable.c
--- libxvmc-20050514-old/driDrawable.c	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/driDrawable.c	2005-05-15 10:24:02.410295095 -0700
@@ -0,0 +1,173 @@
+/*****************************************************************************
+ * driDrawable.c: Lean Version of DRI utilities.
+ *
+ * Copyright (c) 2005 Thomas Hellstrom. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <X11/Xlibint.h>
+#include <Xutil.h>
+#include "xf86drm.h"
+#include "drm.h"
+#include "xf86dri.h"
+#include "drm_sarea.h"
+#include "driDrawable.h"
+
+
+static unsigned
+drawStamp(volatile drm_sarea_t *pSarea, int index)
+{
+    return pSarea->drawableTable[index].stamp;
+}
+
+int
+getDRIDrawableInfoLocked(void *drawHash, Display *display, int screen, Drawable draw,
+			 unsigned lockFlags, int drmFD, drm_context_t drmContext, 
+			 drmAddress sarea, Bool updateInfo, drawableInfo **info, 
+			 unsigned long infoSize)
+{
+  drawableInfo *drawInfo;
+  void *res;
+  drm_drawable_t drmDraw=0;
+  volatile drm_sarea_t *pSarea = (drm_sarea_t *) sarea;
+  drm_clip_rect_t *clipFront, *clipBack;
+
+  int ret;
+
+
+  if (drmHashLookup(drawHash, (unsigned long) draw, &res)) {
+
+      /*
+       * The drawable is unknown to us. Create it and put it in the
+       * hash table.
+       */
+
+      DRM_UNLOCK(drmFD, &pSarea->lock, drmContext); 
+      if (!XF86DRICreateDrawable(display, screen, draw,
+				 &drmDraw)) {
+	DRM_LOCK(drmFD, &pSarea->lock, drmContext, lockFlags); 
+	  return 1;
+      }
+      DRM_LOCK(drmFD, &pSarea->lock, drmContext, lockFlags); 
+
+
+      drawInfo = (drawableInfo *) malloc(infoSize);
+      if (!drawInfo) return 1;
+
+      drawInfo->drmDraw = drmDraw;
+      drawInfo->stamp = 0;
+      drawInfo->clipFront = 0;
+      drawInfo->clipBack = 0;
+
+      drmHashInsert( drawHash, (unsigned long) draw, drawInfo);
+
+  } else {
+      drawInfo = res;
+  }
+
+
+  drawInfo->touched = FALSE;
+  while (!drawInfo->clipFront || drawInfo->stamp != drawStamp(pSarea, drawInfo->index)) {
+
+      /*
+       * The drawable has been touched since we last got info about it.
+       * obtain new info from the X server.
+       */
+
+      drawInfo->touched = TRUE;
+
+      if (updateInfo || !drawInfo->clipFront) {
+	  DRM_UNLOCK(drmFD, &pSarea->lock, drmContext); 
+
+	  ret = XF86DRIGetDrawableInfo(display, screen, draw,
+				       &drawInfo->index, &drawInfo->stamp, &drawInfo->x, 
+				       &drawInfo->y, &drawInfo->w, &drawInfo->h,
+				       &drawInfo->numClipFront, &clipFront, 
+				       &drawInfo->backX, &drawInfo->backY,
+				       &drawInfo->numClipBack, &clipBack);
+	  
+	  DRM_LIGHT_LOCK(drmFD, &pSarea->lock, drmContext); 
+
+	  /*
+	   * Error. Probably the drawable is destroyed. Return error and old values.
+	   */
+
+	  if (!ret) {
+	      free(drawInfo);
+	      drawInfo = NULL;
+	      drmHashDelete(drawHash, (unsigned long) draw);
+	      
+	      DRM_UNLOCK(drmFD, &pSarea->lock, drmContext);
+	      XF86DRIDestroyDrawable( display, screen, draw);
+	      DRM_LOCK(drmFD, &pSarea->lock, drmContext, lockFlags);
+
+	      return 1;
+	  }
+	  
+	  if (drawInfo->stamp != drawStamp(pSarea, drawInfo->index)) {
+
+	      /*
+	       * The info is already outdated. Sigh. Have another go.
+	       */
+
+	      XFree(clipFront);
+	      XFree(clipBack);
+	      continue;
+	  }
+
+	  if (drawInfo->clipFront) XFree(drawInfo->clipFront);
+	  drawInfo->clipFront = clipFront;
+	  if (drawInfo->clipBack) XFree(drawInfo->clipBack);
+	  drawInfo->clipBack = clipBack;
+      } else {
+	  if (!drawInfo->clipFront) drawInfo->clipFront = (drm_clip_rect_t *) ~0UL;
+	  drawInfo->stamp = drawStamp(pSarea, drawInfo->index);
+      }
+  }
+  *info = drawInfo;
+  return 0;
+}
+
+void 
+driDestroyHashContents(void *drawHash)
+{
+    unsigned long key;
+    void *content;
+    drawableInfo *drawInfo;
+
+    
+    if (drmHashFirst(drawHash, &key, &content) < 1) 
+	return;
+    drawInfo = (drawableInfo *) content;
+    if (drawInfo->clipBack) XFree(drawInfo->clipBack);
+    if (drawInfo->clipFront) XFree(drawInfo->clipFront);
+    free(drawInfo);
+    while(drmHashNext(drawHash, &key, &content) == 1) {
+	drawInfo = (drawableInfo *) content;
+	if (drawInfo->clipBack) XFree(drawInfo->clipBack);
+	if (drawInfo->clipFront) XFree(drawInfo->clipFront);
+	free(drawInfo);
+    }
+	
+    return ;
+}
+    
+
+    
diff -Naur libxvmc-20050514-old/driDrawable.h libxvmc-20050514-new/driDrawable.h
--- libxvmc-20050514-old/driDrawable.h	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/driDrawable.h	2005-05-15 10:24:02.411294982 -0700
@@ -0,0 +1,64 @@
+/*****************************************************************************
+ * driDrawable.h: Lean Version of DRI utilities.
+ *
+ * Copyright (c) 2005 Thomas Hellstrom. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRIDRAWABLE_H
+#define _DRIDRAWABLE_H
+
+typedef struct _drawableInfo {
+    drm_drawable_t drmDraw;
+    unsigned stamp;
+    unsigned index;
+    drm_clip_rect_t *clipFront;
+    drm_clip_rect_t *clipBack;
+    int x;
+    int y;
+    int w;
+    int h;
+    int backX;
+    int backY;
+    int numClipFront;
+    int numClipBack;
+    Bool touched;
+} drawableInfo;
+
+/*
+ * Get updated info about the drawable "draw". The drawableInfo record returned is malloced
+ * and administrated internally. Never free it unless you know exactly what you are doing.
+ * The drm hash table "drawHash" needs to be initialized externally.
+ */
+
+extern int
+getDRIDrawableInfoLocked (void *drawHash, Display *display, int screen, Drawable draw,
+			  unsigned lockFlags, int drmFD, drm_context_t drmContext,
+			  drmAddress sarea, Bool updateInfo, drawableInfo **info, 
+			  unsigned long infoSize);
+
+/*
+ * Free all resources created by the above function. Typically done on exit.
+ */
+
+extern void 
+driDestroyHashContents(void *drawHash);
+
+#endif
diff -Naur libxvmc-20050514-old/Imakefile libxvmc-20050514-new/Imakefile
--- libxvmc-20050514-old/Imakefile	2004-09-14 14:20:06.000000000 -0700
+++ libxvmc-20050514-new/Imakefile	2005-05-15 10:24:02.410295095 -0700
@@ -2,12 +2,23 @@
 #define DoSharedLib SharedLibXvMC
 #define DoDebugLib DebugLibXvMC
 #define DoProfileLib ProfileLibXvMC
-#define LibName viaXvMC
+/*#define LibName viaXvMC*/
 #define SoRev SOXVMCREV
 #define LibHeaders NO
 
 #include <Threads.tmpl>
 
+/* Anyone know how to determine this properly?
+ * Uncomment out the following to build outside the x tree
+#define OUTOFTREE
+ */
+
+#ifdef OUTOFTREE
+VIADRIVERSRC=../unichrome
+#else
+VIADRIVERSRC=$(XF86DRIVERSRC)/via
+#endif
+
 #ifdef SharedXvMCReqs
 REQUIREDLIBS = SharedXvMCReqs -lXv
 #endif
@@ -19,15 +30,20 @@
       DEFINES = $(ALLOC_DEFINES) -DTRUE=1 -DFALSE=0
      INCLUDES = -I$(XINCLUDESRC) -I$(INCLUDESRC) -I$(XLIBSRC) -I$(EXTINCSRC) \
 		-I$(XF86COMSRC) -I$(XF86OSSRC) -I$(DRMSRCDIR)/shared \
-		-I$(XF86OSSRC)/linux/drm/kernel -I$(XF86DRIVERSRC)/via
-         SRCS = viaXvMC.c viaLowLevel.c 
+		-I$(XF86OSSRC)/linux/drm/kernel -I$(VIADRIVERSRC)
+         SRCS = viaXvMC.c viaLowLevel.c viaLowLevelPro.c xf86dri.c driDrawable.c
          OBJS = viaXvMC.o viaLowLevel.o xf86drm.o xf86drmHash.o \
-	        xf86drmRandom.o xf86drmSL.o
+	        xf86drmRandom.o xf86drmSL.o xf86dri.o driDrawable.o
+         OBJSPRO = viaXvMC.o viaLowLevelPro.o xf86drm.o xf86drmHash.o \
+	        xf86drmRandom.o xf86drmSL.o xf86dri.o driDrawable.o
      LINTLIBS = $(LINTXLIB)
 
-
 #include <Library.tmpl>
 
+SharedLibraryTarget(viaXvMC,$(SoRev),$(OBJS) $(EXTRASHAREDOBJS),.,.)
+SharedLibraryTarget(viaXvMCPro,$(SoRev),$(OBJSPRO) $(EXTRASHAREDOBJS),.,.)
+InstallSharedLibrary(viaXvMC,$(SoRev),$(SHLIBDIR))
+InstallSharedLibrary(viaXvMCPro,$(SoRev),$(SHLIBDIR))
 
 #if defined(LinuxArchitecture)
 OS_SUBDIR = linux
diff -Naur libxvmc-20050514-old/viaLowLevel.c libxvmc-20050514-new/viaLowLevel.c
--- libxvmc-20050514-old/viaLowLevel.c	2005-03-14 15:38:50.000000000 -0800
+++ libxvmc-20050514-new/viaLowLevel.c	2005-05-15 10:24:02.411294982 -0700
@@ -934,7 +934,7 @@
 int 
 initXvMCLowLevel(XvMCLowLevel *xl, int fd, drm_context_t *ctx,
 		 drmLockPtr hwLock, drmAddress mmioAddress, 
-		 drmAddress fbAddress, int useAgp) 
+		 drmAddress fbAddress, int useAgp, unsigned cardId) 
 {
     xl->agp_pos = 0;
     xl->pci_pos = 0;
diff -Naur libxvmc-20050514-old/viaLowLevel.h libxvmc-20050514-new/viaLowLevel.h
--- libxvmc-20050514-old/viaLowLevel.h	2005-03-14 15:38:50.000000000 -0800
+++ libxvmc-20050514-new/viaLowLevel.h	2005-05-15 10:24:02.412294869 -0700
@@ -74,7 +74,10 @@
     unsigned agp_pos;
     unsigned pci_pos;
     unsigned flip_pos;
-    int use_agp;
+    int use_agp;   
+    int agp_mode;
+    int agp_header_start;
+    int agp_index;
     int fd;
     drm_context_t *drmcontext;
     drmLockPtr hwLock;
@@ -90,12 +93,13 @@
     CARD32 lastReadTimeStamp;
     int agpSync;
     CARD32 agpSyncTimeStamp;
+    unsigned chipId;
 }XvMCLowLevel;
 
 
 extern int initXvMCLowLevel(XvMCLowLevel *xl, int fd, drm_context_t *ctx,
 			     drmLockPtr hwLock, drmAddress mmioAddress,
-			     drmAddress fbAddress,int useAgp);
+			     drmAddress fbAddress,int useAgp, unsigned chipId );
 
 extern void setLowLevelLocking(XvMCLowLevel *xl, int perFormLocking);
 extern void closeXvMCLowLevel(XvMCLowLevel *xl);
@@ -118,10 +122,16 @@
 
 #define LL_HW_LOCK(xl)							\
     do {								\
-	DRM_LOCK((xl)->fd,(xl)->hwLock,*(xl)->drmcontext,0); } while(0);
+	DRM_LOCK((xl)->fd,(xl)->hwLock,*(xl)->drmcontext,0);		\
+    } while(0);
 #define LL_HW_UNLOCK(xl)					\
-    do {DRM_UNLOCK((xl)->fd,(xl)->hwLock,*(xl)->drmcontext);	\
+    do {							\
+	DRM_UNLOCK((xl)->fd,(xl)->hwLock,*(xl)->drmcontext);	\
     } while(0);
 
+#define PCI_CHIP_VT3204         0x3108 /* K8M800 */
+#define PCI_CHIP_VT3259         0x3118 /* PM800/PM880/CN400 */
+#define PCI_CHIP_CLE3122        0x3122 /* CLE266 */
+#define PCI_CHIP_VT3205         0x7205 /* KM400 */
 
 #endif
diff -Naur libxvmc-20050514-old/viaLowLevelPro.c libxvmc-20050514-new/viaLowLevelPro.c
--- libxvmc-20050514-old/viaLowLevelPro.c	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/viaLowLevelPro.c	2005-05-15 10:24:02.414294643 -0700
@@ -0,0 +1,1168 @@
+/*****************************************************************************
+ * VIA Unichrome XvMC extension client lib.
+ *
+ * Copyright (c) 2004 Thomas Hellström. All rights reserved.
+ * Copyright (c) 2003 Andreas Robinson. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * Low-level functions that deal directly with the hardware. In the future,
+ * these functions might be implemented in a kernel module. Also, some of them
+ * would benefit from DMA.
+ *
+ * Authors: Andreas Robinson 2003. Thomas Hellström 2004. Ivor Hewitt 2005.
+ */
+
+/* IH
+ * I've left the proReg or-ing in case we need/want to implement the V1/V3
+ * register toggle too, which also moves the register locations.
+ * The CN400 has dual mpeg decoders, not sure at the moment whether these
+ * are also operated through independent registers also.
+ */
+
+#define VIDEO_DMA
+#define HQV_USE_IRQ
+
+#include "viaXvMCPriv.h"
+#include "viaLowLevel.h"
+#include <time.h>
+#include <sys/time.h>
+#include <stdio.h>
+
+
+/*
+ * For Other architectures than i386 these might have to be modified for
+ * bigendian etc.
+ */
+
+#define MPEGIN(xl,reg)							\
+    *((volatile CARD32 *)(((CARD8 *)(xl)->mmioAddress) + 0xc00 + (reg)))
+
+#define VIDIN(ctx,reg)							\
+    *((volatile CARD32 *)(((CARD8 *)(ctx)->mmioAddress) + 0x200 + (reg)))
+
+#define REGIN(ctx,reg)							\
+    *((volatile CARD32 *)(((CARD8 *)(ctx)->mmioAddress) + 0x0000 + (reg)))
+
+#define HQV_CONTROL             0x1D0
+#define HQV_SRC_OFFSET          0x1CC
+#define HQV_SRC_STARTADDR_Y     0x1D4
+#define HQV_SRC_STARTADDR_U     0x1D8
+#define HQV_SRC_STARTADDR_V     0x1DC
+#define HQV_MINIFY_DEBLOCK      0x1E8    
+
+#define REG_HQV1_INDEX      0x00001000
+    
+#define HQV_SW_FLIP         0x00000010
+#define HQV_FLIP_STATUS     0x00000001
+#define HQV_SUBPIC_FLIP     0x00008000
+#define HQV_FLIP_ODD        0x00000020
+#define HQV_DEINTERLACE     0x00010000
+#define HQV_FIELD_2_FRAME   0x00020000
+#define HQV_FRAME_2_FIELD   0x00040000
+#define HQV_FIELD_UV        0x00100000
+#define HQV_DEBLOCK_HOR     0x00008000
+#define HQV_DEBLOCK_VER     0x80000000
+#define HQV_YUV420          0xC0000000
+#define HQV_YUV422          0x80000000
+#define HQV_ENABLE          0x08000000
+#define HQV_GEN_IRQ         0x00000080
+
+#define V_COMPOSE_MODE          0x98
+#define V1_COMMAND_FIRE         0x80000000  
+#define V3_COMMAND_FIRE         0x40000000  
+
+/* SUBPICTURE Registers */
+#define SUBP_CONTROL_STRIDE     0x1C0
+#define SUBP_STARTADDR          0x1C4
+#define RAM_TABLE_CONTROL       0x1C8
+#define RAM_TABLE_READ          0x1CC
+
+/* SUBP_CONTROL_STRIDE              0x3c0 */
+#define SUBP_HQV_ENABLE             0x00010000
+#define SUBP_IA44                   0x00020000
+#define SUBP_AI44                   0x00000000
+#define SUBP_STRIDE_MASK            0x00001fff
+#define SUBP_CONTROL_MASK           0x00070000
+
+/* RAM_TABLE_CONTROL                0x3c8 */
+#define RAM_TABLE_RGB_ENABLE        0x00000007
+
+
+#define VIA_REG_STATUS          0x400
+#define VIA_REG_GEMODE          0x004
+#define VIA_REG_SRCBASE         0x030
+#define VIA_REG_DSTBASE         0x034
+#define VIA_REG_PITCH           0x038      
+#define VIA_REG_SRCCOLORKEY     0x01C      
+#define VIA_REG_KEYCONTROL      0x02C       
+#define VIA_REG_SRCPOS          0x008
+#define VIA_REG_DSTPOS          0x00C
+#define VIA_REG_GECMD           0x000
+#define VIA_REG_DIMENSION       0x010       /* width and height */
+#define VIA_REG_FGCOLOR         0x018
+
+
+#define VIA_VR_QUEUE_BUSY       0x00020000 /* Virtual Queue is busy */
+#define VIA_CMD_RGTR_BUSY       0x00000080  /* Command Regulator is busy */
+#define VIA_2D_ENG_BUSY         0x00000001  /* 2D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000002  /* 3D Engine is busy */
+#define VIA_GEM_8bpp            0x00000000
+#define VIA_GEM_16bpp           0x00000100
+#define VIA_GEM_32bpp           0x00000300
+#define VIA_GEC_BLT             0x00000001
+#define VIA_PITCH_ENABLE        0x80000000
+#define VIA_GEC_INCX            0x00000000
+#define VIA_GEC_DECY            0x00004000
+#define VIA_GEC_INCY            0x00000000
+#define VIA_GEC_DECX            0x00008000
+#define VIA_GEC_FIXCOLOR_PAT    0x00002000
+
+
+#define VIA_BLIT_CLEAR 0x00
+#define VIA_BLIT_COPY 0xCC
+#define VIA_BLIT_FILL 0xF0
+#define VIA_BLIT_SET 0xFF
+
+#define VIA_SYNCWAITTIMEOUT 50000 /* Might be a bit conservative */
+#define VIA_DMAWAITTIMEOUT 150000
+#define VIA_VIDWAITTIMEOUT 50000
+#define VIA_XVMC_DECODERTIMEOUT 50000 /*(microseconds)*/
+
+#define VIA_AGP_HEADER5 0xFE040000
+#define VIA_AGP_HEADER6 0xFE050000
+
+#define H1_ADDR(val) (((val) >> 2) | 0xF0000000)
+#define WAITFLAGS(xl, flags)			\
+    (xl)->curWaitFlags |= (flags)
+#define BEGIN_RING_AGP(xl,size)						\
+    do {								\
+	if ((xl)->agp_pos > (LL_AGP_CMDBUF_SIZE-(size))) {		\
+	    agpFlush(xl);						\
+	}								\
+    } while(0)
+#define OUT_RING_AGP(xl, val) do{			\
+	(xl)->agp_buffer[(xl)->agp_pos++] = (val);	\
+  } while(0);		
+
+#define OUT_RING_QW_AGP(xl, val1, val2)			\
+    do {						\
+	(xl)->agp_buffer[(xl)->agp_pos++] = (val1);	\
+	(xl)->agp_buffer[(xl)->agp_pos++] = (val2);	\
+    } while (0)
+  
+
+#define BEGIN_HEADER5_AGP(xl, index)		\
+    do {					\
+	BEGIN_RING_AGP(xl, 8);			\
+	(xl)->agp_mode = VIA_AGP_HEADER5;	\
+        (xl)->agp_index = (index);              \
+	(xl)->agp_header_start = (xl)->agp_pos; \
+	(xl)->agp_pos += 4;			\
+    } while (0)
+
+#define BEGIN_HEADER6_AGP(xl)			\
+    do {					\
+	BEGIN_RING_AGP(xl, 8);			\
+	(xl)->agp_mode = VIA_AGP_HEADER6;	\
+	(xl)->agp_header_start = (xl)->agp_pos; \
+	(xl)->agp_pos += 4;			\
+    } while (0)
+
+#define BEGIN_HEADER5_DATA(xl, size, index)				\
+    do {								\
+	if ((xl)->agp_pos > (LL_AGP_CMDBUF_SIZE-((size) + 16))) {	\
+	    agpFlush(xl);						\
+	    BEGIN_HEADER5_AGP((xl), (index));				\
+	} else if ((xl)->agp_mode && (((xl)->agp_mode != VIA_AGP_HEADER5) || \
+				      (xl)->agp_index != index)) {	\
+	    finish_header_agp(xl);					\
+	    BEGIN_HEADER5_AGP((xl), (index));				\
+	}								\
+	else if ((xl->agp_mode != VIA_AGP_HEADER5)) {			\
+	    BEGIN_HEADER5_AGP((xl), (index));				\
+	}								\
+    }while(0)
+
+#define BEGIN_HEADER6_DATA(xl, size)					\
+    do{									\
+	if ((xl)->agp_pos > (LL_AGP_CMDBUF_SIZE-(((size) << 1) + 16))) {	\
+	    agpFlush(xl);						\
+	    BEGIN_HEADER6_AGP((xl));					\
+	} else	if ((xl)->agp_mode && ((xl)->agp_mode != VIA_AGP_HEADER6)) { \
+	    finish_header_agp(xl);					\
+	    BEGIN_HEADER6_AGP(xl);					\
+	}								\
+	else if ((xl->agp_mode != VIA_AGP_HEADER6)) {			\
+	    BEGIN_HEADER6_AGP((xl));					\
+	}								\
+    }while(0)
+
+
+static void
+finish_header_agp(XvMCLowLevel *xl) 
+{
+    int
+      numDWords,i;
+    CARD32
+	*hb;
+
+    if (!xl->agp_mode) return;
+    numDWords = xl->agp_pos - xl->agp_header_start - 4; 
+    hb = xl->agp_buffer + xl->agp_header_start;
+    switch (xl->agp_mode) {
+    case VIA_AGP_HEADER5:
+	hb[0] = VIA_AGP_HEADER5 | xl->agp_index;
+	hb[1] = numDWords ;
+	hb[2] = 0x00F50000; /* SW debug flag. (?) */
+	break;
+    default:
+	hb[0] = VIA_AGP_HEADER6;
+	hb[1] = numDWords >> 1 ;
+	hb[2] = 0x00F60000; /* SW debug flag. (?) */
+	break;
+    }
+    hb[3] = 0;
+    if (numDWords & 3) {
+	for (i=0; i<(4 - (numDWords & 3)); ++i) 
+	    OUT_RING_AGP(xl, 0x00000000);
+    }
+    xl->agp_mode = 0;
+}
+
+void 
+hwlLock(XvMCLowLevel *xl, int videoLock) 
+{
+    LL_HW_LOCK(xl);
+}
+
+void 
+hwlUnlock(XvMCLowLevel *xl, int videoLock) 
+{
+    LL_HW_UNLOCK(xl);
+}
+    
+static unsigned 
+timeDiff(struct timeval *now,struct timeval *then) {
+    return (now->tv_usec >= then->tv_usec) ?
+	now->tv_usec - then->tv_usec : 
+	1000000 - (then->tv_usec - now->tv_usec);
+}
+
+void 
+setAGPSyncLowLevel(XvMCLowLevel *xl, int val, CARD32 timeStamp)
+{
+    xl->agpSync = val;
+    xl->agpSyncTimeStamp = timeStamp;
+}
+
+CARD32 
+viaDMATimeStampLowLevel(XvMCLowLevel *xl)
+{
+    if (xl->use_agp) {
+	viaBlit(xl, 32, xl->tsOffset, 1, xl->tsOffset, 1, 1, 1, 0, 0, 
+		VIABLIT_FILL, xl->curTimeStamp);
+	return xl->curTimeStamp++;
+    }
+    return 0;
+}
+
+static void 
+viaDMAWaitTimeStamp(XvMCLowLevel *xl, CARD32 timeStamp, int doSleep) 
+{
+    struct timeval now, then;
+    struct timezone here;
+    struct timespec sleep, rem;
+
+    if (xl->use_agp && (xl->lastReadTimeStamp - timeStamp > (1 << 23))) {
+	sleep.tv_nsec = 1;
+	sleep.tv_sec = 0;
+	here.tz_minuteswest = 0;
+	here.tz_dsttime = 0;
+	gettimeofday(&then,&here);
+ 
+	while(((xl->lastReadTimeStamp = *xl->tsP) - timeStamp) > (1 << 23)) {
+	    gettimeofday(&now,&here); 
+	    if (timeDiff(&now,&then) > VIA_DMAWAITTIMEOUT) {
+		if(((xl->lastReadTimeStamp = *xl->tsP) - timeStamp) > (1 << 23)) {
+		    xl->errors |= LL_DMA_TIMEDOUT;
+		    break;
+		}
+	    }
+	    if (doSleep) nanosleep(&sleep, &rem);
+	}
+    }
+}
+
+static int 
+viaDMAInitTimeStamp(XvMCLowLevel *xl) 
+{
+    int ret = 0;
+
+    if (xl->use_agp) {
+	xl->tsMem.context = *(xl->drmcontext);
+	xl->tsMem.size = 64;
+	xl->tsMem.type = VIDEO;
+	if (drmCommandWriteRead(xl->fd, DRM_VIA_ALLOCMEM, &xl->tsMem, sizeof(xl->tsMem)) < 0) 
+	    return ret;
+	if (xl->tsMem.size != 64)
+	    return -1;
+	xl->tsOffset = (xl->tsMem.offset + 31) & ~31; 
+	xl->tsP = (CARD32 *)xl->fbAddress + (xl->tsOffset >> 2); 
+	xl->curTimeStamp = 1;
+	*xl->tsP = 0;
+    }
+    return 0;
+}
+
+static int 
+viaDMACleanupTimeStamp(XvMCLowLevel *xl) 
+{
+
+    if (!(xl->tsMem.size) || !xl->use_agp) return 0;
+    return drmCommandWrite(xl->fd, DRM_VIA_FREEMEM, &xl->tsMem, sizeof(xl->tsMem)); 
+}
+
+
+static CARD32 
+viaMpegGetStatus(XvMCLowLevel *xl)
+{
+    return MPEGIN(xl,0x54);
+}
+
+static int 
+viaMpegIsBusy(XvMCLowLevel *xl, CARD32 mask, CARD32 idle)
+{
+    CARD32 tmp = viaMpegGetStatus(xl);
+
+    /*
+     * Error detected. 
+     * FIXME: Are errors really shown when error concealment is on?
+     */
+
+    if (tmp & 0x70) return 0; 
+
+    return (tmp & mask) != idle;
+}
+
+
+static void 
+syncDMA(XvMCLowLevel *xl, unsigned int doSleep)
+{
+  
+    /*
+     * Ideally, we'd like to have an interrupt wait here, but, according to second hand
+     * information, the hardware does not support this, although earlier S3 chips do that.
+     * It is therefore not implemented into the DRM, and we'll do a user space wait here.
+     */
+
+    struct timeval now, then;
+    struct timezone here;
+    struct timespec sleep, rem;
+
+   
+    sleep.tv_nsec = 1;
+    sleep.tv_sec = 0;
+    here.tz_minuteswest = 0;
+    here.tz_dsttime = 0;
+    gettimeofday(&then,&here);
+    while( !(REGIN(xl, VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY)) {
+	gettimeofday(&now,&here); 
+	if (timeDiff(&now,&then) > VIA_DMAWAITTIMEOUT) {
+	    if( !(REGIN(xl, VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY)) {
+		xl->errors |= LL_DMA_TIMEDOUT;
+		break;
+	    }
+	}
+	if (doSleep) nanosleep(&sleep, &rem);
+    }
+    while( REGIN(xl, VIA_REG_STATUS) & VIA_CMD_RGTR_BUSY ) {
+	gettimeofday(&now,&here); 
+	if (timeDiff(&now,&then) > VIA_DMAWAITTIMEOUT) {
+	    if( REGIN(xl, VIA_REG_STATUS) & VIA_CMD_RGTR_BUSY ) {
+		xl->errors |= LL_DMA_TIMEDOUT;
+		break;
+	    }
+	}
+	if (doSleep) nanosleep(&sleep, &rem);
+    }
+}
+
+#ifdef HQV_USE_IRQ
+static void 
+syncVideo(XvMCLowLevel *xl, unsigned int doSleep)
+{
+    int proReg=0;
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;
+
+    /*
+     * Wait for HQV completion using completion interrupt. Nothing strange here. 
+     * Note that the interrupt handler clears the HQV_FLIP_STATUS bit, so we 
+     * can't wait on that one.
+     */
+    
+  if ((VIDIN(xl, HQV_CONTROL|proReg) & (HQV_SW_FLIP | HQV_SUBPIC_FLIP))) {
+	drm_via_irqwait_t irqw;
+	irqw.request.irq = 1;
+	irqw.request.type = VIA_IRQ_ABSOLUTE;
+	if (drmCommandWriteRead(xl->fd, DRM_VIA_WAIT_IRQ, &irqw, sizeof(irqw)) < 0) 
+	    xl->errors |= LL_VIDEO_TIMEDOUT;
+  }
+}
+#else
+static void 
+syncVideo(XvMCLowLevel *xl, unsigned int doSleep)
+{
+    /*
+     * Wait for HQV completion. Nothing strange here. We assume that the HQV
+     * Handles syncing to the V1 / V3 engines by itself. It should be safe to
+     * always wait for SUBPIC_FLIP completion although subpictures are not always
+     * used. 
+     */
+    
+    struct timeval now, then;
+    struct timezone here;
+    struct timespec sleep, rem;
+
+    int proReg=0;
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;
+
+    sleep.tv_nsec = 1;
+    sleep.tv_sec = 0;
+    here.tz_minuteswest = 0;
+    here.tz_dsttime = 0;
+    gettimeofday(&then,&here); 
+    while((VIDIN(xl, HQV_CONTROL|proReg) & (HQV_SW_FLIP | HQV_SUBPIC_FLIP  )) ) {
+	gettimeofday(&now,&here); 
+	if (timeDiff(&now,&then) > VIA_SYNCWAITTIMEOUT) {
+	  if((VIDIN(xl, HQV_CONTROL|proReg) & (HQV_SW_FLIP | HQV_SUBPIC_FLIP )) ) {
+		xl->errors |= LL_VIDEO_TIMEDOUT;
+		break;
+	    }
+	}
+	if (doSleep) nanosleep(&sleep, &rem);
+    }
+}
+#endif
+
+static void 
+syncAccel(XvMCLowLevel *xl, unsigned int mode, unsigned int doSleep)
+{
+    struct timeval now, then;
+    struct timezone here;
+    struct timespec sleep, rem;
+    CARD32 mask = ((mode & LL_MODE_2D) ? VIA_2D_ENG_BUSY : 0) |
+	((mode & LL_MODE_3D) ? VIA_3D_ENG_BUSY : 0);
+
+    sleep.tv_nsec = 1;
+    sleep.tv_sec = 0;
+    here.tz_minuteswest = 0;
+    here.tz_dsttime = 0;
+    gettimeofday(&then,&here); 
+    while( REGIN(xl, VIA_REG_STATUS) & mask) {
+	gettimeofday(&now,&here); 
+	if (timeDiff(&now,&then) > VIA_SYNCWAITTIMEOUT) {
+	    if( REGIN(xl, VIA_REG_STATUS) & mask) {
+		xl->errors |= LL_ACCEL_TIMEDOUT;
+		break;
+	    }
+	}
+	if (doSleep) nanosleep(&sleep, &rem);
+    }
+}
+
+
+static void 
+syncMpeg(XvMCLowLevel *xl, unsigned int mode, unsigned int doSleep)
+{
+    /*
+     * Ideally, we'd like to have an interrupt wait here, but from information from VIA
+     * at least the MPEG completion interrupt is broken on the CLE266, which was
+     * discovered during validation of the chip.
+     */
+
+    struct timeval now, then;
+    struct timezone here;
+    struct timespec sleep, rem;
+    CARD32 busyMask = 0;
+    CARD32 idleVal = 0;
+    CARD32 ret;
+
+    sleep.tv_nsec = 1;
+    sleep.tv_sec = 0;
+    here.tz_minuteswest = 0;
+    here.tz_dsttime = 0;
+    gettimeofday(&then,&here); 
+    if (mode & LL_MODE_DECODER_SLICE) {
+	busyMask = VIA_SLICEBUSYMASK;
+	idleVal = VIA_SLICEIDLEVAL;
+    }
+    if (mode & LL_MODE_DECODER_IDLE) {
+	busyMask |= VIA_BUSYMASK;
+	idleVal = VIA_IDLEVAL;
+    }
+    while(viaMpegIsBusy(xl, busyMask, idleVal)) {
+	gettimeofday(&now,&here); 
+	if (timeDiff(&now,&then) > VIA_XVMC_DECODERTIMEOUT) {
+	    if (viaMpegIsBusy(xl, busyMask, idleVal)) {
+		xl->errors |= LL_DECODER_TIMEDOUT;
+	    }
+	    break;
+	}
+	if (doSleep) nanosleep(&sleep, &rem);
+    }
+  
+    ret = viaMpegGetStatus(xl);
+    if (ret & 0x70) {
+	xl->errors |= ((ret & 0x70) >> 3);
+    }
+    return;
+}
+
+static void 
+pciFlush(XvMCLowLevel *xl)
+{
+    int ret;
+    drm_via_cmdbuffer_t b;
+    unsigned mode=xl->curWaitFlags;
+  
+    finish_header_agp(xl);
+    b.buf = (char *)xl->pci_buffer;
+    b.size = xl->pci_pos * sizeof(CARD32);
+    if (xl->performLocking) hwlLock(xl,0);
+    if ((mode != LL_MODE_VIDEO) && (mode != 0)) {
+      syncDMA(xl, 0);
+    }
+    if ((mode & LL_MODE_2D) || (mode & LL_MODE_3D)) {
+      syncAccel(xl, mode, 0); 
+    }
+    if (mode & LL_MODE_VIDEO) {
+      syncVideo(xl, 1);
+    }
+    if (mode & (LL_MODE_DECODER_SLICE | LL_MODE_DECODER_IDLE)) {
+      syncMpeg(xl, mode, 0); 
+    }
+    ret = drmCommandWrite(xl->fd, DRM_VIA_PCICMD, &b, sizeof(b));
+    if (xl->performLocking) hwlUnlock(xl,0);
+    if (ret) {
+	xl->errors |= LL_PCI_COMMAND_ERR;
+    }
+    xl->pci_pos = 0;
+    xl->curWaitFlags = 0;
+}
+  
+static void 
+agpFlush(XvMCLowLevel *xl)
+{
+    drm_via_cmdbuffer_t b;
+    int ret;
+    int i;
+
+    finish_header_agp(xl);
+    if (xl->use_agp) {
+	b.buf = (char *)xl->agp_buffer;
+	b.size = xl->agp_pos * sizeof(CARD32);
+	if (xl->agpSync) {
+	    syncXvMCLowLevel(xl, LL_MODE_DECODER_IDLE, 1, xl->agpSyncTimeStamp);
+	    xl->agpSync = 0;
+	}
+	if (xl->performLocking) hwlLock(xl,0);
+	do {
+	    ret = drmCommandWrite(xl->fd, DRM_VIA_CMDBUFFER, &b, sizeof(b));
+	} while (-EAGAIN == ret);
+	if (xl->performLocking) hwlUnlock(xl,0);
+      
+	if (ret) {
+	    xl->errors |= LL_AGP_COMMAND_ERR;
+	    for(i=0; i<xl->agp_pos; i+=2) {
+	      printf("0x%lx, 0x%lx\n", xl->agp_buffer[i], xl->agp_buffer[i+1]);
+	    }
+	    exit(-1);
+	} else {
+	    xl->agp_pos = 0;
+	}
+	xl->curWaitFlags &= LL_MODE_VIDEO;
+    } else {
+	unsigned mode=xl->curWaitFlags;
+  
+	b.buf = (char *)xl->agp_buffer;
+	b.size = xl->agp_pos * sizeof(CARD32);
+	if (xl->performLocking) hwlLock(xl,0);
+	if ((mode != LL_MODE_VIDEO) && (mode != 0)) 
+	    syncDMA(xl, 0);
+	if ((mode & LL_MODE_2D) || (mode & LL_MODE_3D)) 
+	    syncAccel(xl, mode, 0);
+	if (mode & LL_MODE_VIDEO) 
+	    syncVideo(xl, 1);
+	if (mode & (LL_MODE_DECODER_SLICE | LL_MODE_DECODER_IDLE))
+	    syncMpeg(xl, mode, 0);
+	ret = drmCommandWrite(xl->fd, DRM_VIA_PCICMD, &b, sizeof(b));
+	if (xl->performLocking) hwlUnlock(xl,0);
+	if (ret) {
+	    xl->errors |= LL_PCI_COMMAND_ERR;
+	}
+	xl->agp_pos = 0;
+	xl->curWaitFlags = 0;
+    }      
+}
+
+unsigned 
+flushXvMCLowLevel(XvMCLowLevel *xl) 
+{
+    unsigned 
+	errors;
+
+    if(xl->pci_pos) pciFlush(xl);
+    if(xl->agp_pos) agpFlush(xl);
+    errors = xl->errors;
+    if (errors) printf("Error 0x%x\n", errors);
+    xl->errors = 0;
+    return errors;
+}
+
+void 
+flushPCIXvMCLowLevel(XvMCLowLevel *xl) 
+{
+    if(xl->pci_pos) pciFlush(xl); 
+    if ((!xl->use_agp &&  xl->agp_pos)) agpFlush(xl);
+}
+
+
+__inline static void pciCommand(XvMCLowLevel *xl, unsigned offset, unsigned value, unsigned flags)
+{
+    if (xl->pci_pos > (LL_PCI_CMDBUF_SIZE-2)) pciFlush(xl); 
+    if (flags) xl->curWaitFlags |= flags;
+    xl->pci_buffer[xl->pci_pos++] = /*(offset >> 2) | 0xF0000000;*/ offset;
+    xl->pci_buffer[xl->pci_pos++] = value;
+}
+
+void 
+viaMpegSetSurfaceStride(XvMCLowLevel * xl, ViaXvMCContext *ctx)
+{
+    CARD32 y_stride = ctx->yStride;
+    CARD32 uv_stride = y_stride >> 1;
+    
+    BEGIN_HEADER6_DATA(xl, 1);
+    OUT_RING_QW_AGP(xl, 0xc50, (y_stride >> 3) | ((uv_stride >> 3) << 16)); 
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+}
+
+
+void 
+viaVideoSetSWFLipLocked(XvMCLowLevel *xl,
+			unsigned yOffs,
+			unsigned uOffs,
+			unsigned vOffs) {
+    int proReg=0;
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;    
+
+#ifdef VIDEO_DMA
+    BEGIN_HEADER6_DATA(xl, 3);
+    OUT_RING_QW_AGP(xl, (proReg|HQV_SRC_OFFSET) + 0x200 , 0);
+    OUT_RING_QW_AGP(xl, (proReg|HQV_SRC_STARTADDR_Y) + 0x200, yOffs);
+    OUT_RING_QW_AGP(xl, (proReg|HQV_SRC_STARTADDR_U) + 0x200, vOffs);
+    WAITFLAGS(xl, LL_MODE_VIDEO); 
+#else
+    pciCommand(xl, VIA_AGP_HEADER6, 3, LL_MODE_VIDEO);
+    pciCommand(xl, 0x00F60000, 0, 0);
+    pciCommand(xl, proReg|HQV_SRC_OFFSET + 0x200 , 0, 0);
+    pciCommand(xl, proReg|HQV_SRC_STARTADDR_Y + 0x200, yOffs, 0);
+    pciCommand(xl, proReg|HQV_SRC_STARTADDR_U + 0x200, vOffs, 0);
+#endif
+}
+    
+void 
+viaVideoSWFlipLocked(XvMCLowLevel *xl, unsigned flags,
+		     int progressiveSequence)
+{
+    int proReg=0;
+    CARD32 andWd,orWd;
+    andWd = 0;
+    orWd = HQV_ENABLE;
+
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;    
+    
+    if ((flags & XVMC_FRAME_PICTURE) == XVMC_BOTTOM_FIELD) {
+	andWd = 0xFFFFFFFFU;
+	orWd = HQV_FIELD_UV   |
+	    HQV_DEINTERLACE   |
+	    HQV_FIELD_2_FRAME |
+	    HQV_FRAME_2_FIELD |
+	    HQV_YUV420        |
+	    HQV_SW_FLIP       |
+	    HQV_FLIP_STATUS   |
+	    HQV_SUBPIC_FLIP;
+    } else if ((flags & XVMC_FRAME_PICTURE) == XVMC_TOP_FIELD) {
+	andWd = ~HQV_FLIP_ODD;
+	orWd = HQV_FIELD_UV   |
+	    HQV_DEINTERLACE   |
+	    HQV_FIELD_2_FRAME |
+	    HQV_FRAME_2_FIELD |
+	    HQV_YUV420        |
+	    HQV_FLIP_ODD      |
+	    HQV_SW_FLIP       |
+	    HQV_FLIP_STATUS   |
+	    HQV_SUBPIC_FLIP;
+    } else if ((flags & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
+	andWd = ~(HQV_DEINTERLACE   | 
+		  HQV_FRAME_2_FIELD |
+		  HQV_FIELD_2_FRAME |
+		  HQV_FIELD_UV);
+	orWd = HQV_YUV420 | 
+	    HQV_SW_FLIP   |
+	    HQV_FLIP_STATUS  |
+	    HQV_SUBPIC_FLIP;
+    }	    
+    if (progressiveSequence) {
+        andWd &= ~HQV_FIELD_UV;
+        orWd &= ~HQV_FIELD_UV;
+    }
+    
+#ifdef VIDEO_DMA
+    syncVideo(xl,1);
+    BEGIN_HEADER6_DATA(xl, 1);
+    OUT_RING_QW_AGP(xl, (proReg|HQV_CONTROL) + 0x200 , HQV_ENABLE | HQV_GEN_IRQ | orWd);
+    WAITFLAGS(xl, LL_MODE_VIDEO);
+    agpFlush(xl);
+#else
+    pciCommand(xl, VIA_AGP_HEADER6, 1, LL_MODE_VIDEO);
+    pciCommand(xl, 0x00F60000, 0, 0);
+    pciCommand(xl, (proReg|HQV_CONTROL) + 0x200 , HQV_ENABLE | HQV_GEN_IRQ | orWd , 0);
+    pciCommand(xl, 0, 0, 0);
+#endif
+}
+
+	
+void 
+viaMpegSetFB(XvMCLowLevel *xl,unsigned i,
+	     unsigned yOffs,
+	     unsigned uOffs,
+	     unsigned vOffs) {
+
+    i *= (4*2);
+    BEGIN_HEADER6_DATA(xl, 2);
+    OUT_RING_QW_AGP(xl, 0xc28 + i, yOffs >> 3);
+    OUT_RING_QW_AGP(xl, 0xc2c + i, vOffs >> 3);
+
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+}
+
+void 
+viaMpegBeginPicture(XvMCLowLevel *xl,ViaXvMCContext *ctx,
+		    unsigned width,
+		    unsigned height,
+		    const XvMCMpegControl *control) {
+				  
+    unsigned j, mb_width, mb_height;
+    mb_width = (width + 15) >> 4;
+
+    mb_height =
+	((control->mpeg_coding == XVMC_MPEG_2) && 
+	 (control->flags & XVMC_PROGRESSIVE_SEQUENCE)) ?
+	2*((height+31) >> 5) : (((height+15) >> 4));
+
+    BEGIN_HEADER6_DATA(xl, 72);
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+
+    OUT_RING_QW_AGP(xl, 0xc00,
+		    ((control->picture_structure & XVMC_FRAME_PICTURE) << 2) |
+		    ((control->picture_coding_type & 3) << 4) |
+		    ((control->flags & XVMC_ALTERNATE_SCAN) ? (1 << 6) : 0));
+   
+    if (!(ctx->intraLoaded)) {
+	OUT_RING_QW_AGP(xl, 0xc5c, 0);
+	for (j = 0; j < 64; j += 4) {
+            OUT_RING_QW_AGP(xl, 0xc60,  
+			    ctx->intra_quantiser_matrix[j] |
+			    (ctx->intra_quantiser_matrix[j+1] << 8) |
+			    (ctx->intra_quantiser_matrix[j+2] << 16) |
+			    (ctx->intra_quantiser_matrix[j+3] << 24));
+        }
+	ctx->intraLoaded = 1;
+    }
+
+    if (!(ctx->nonIntraLoaded)) {
+	OUT_RING_QW_AGP(xl, 0xc5c, 1);
+	for (j = 0; j < 64; j += 4) {
+            OUT_RING_QW_AGP(xl, 0xc60,  
+			    ctx->non_intra_quantiser_matrix[j] |
+			    (ctx->non_intra_quantiser_matrix[j+1] << 8) |
+			    (ctx->non_intra_quantiser_matrix[j+2] << 16) |
+			    (ctx->non_intra_quantiser_matrix[j+3] << 24));
+        }
+	ctx->nonIntraLoaded = 1;
+    }
+
+    if (!(ctx->chromaIntraLoaded)) {
+	OUT_RING_QW_AGP(xl, 0xc5c, 2);
+	for (j = 0; j < 64; j += 4) {
+            OUT_RING_QW_AGP(xl, 0xc60,  
+			    ctx->chroma_intra_quantiser_matrix[j] |
+			    (ctx->chroma_intra_quantiser_matrix[j+1] << 8) |
+			    (ctx->chroma_intra_quantiser_matrix[j+2] << 16) |
+			    (ctx->chroma_intra_quantiser_matrix[j+3] << 24));
+        }
+	ctx->chromaIntraLoaded = 1;
+    }
+
+    if (!(ctx->chromaNonIntraLoaded)) {
+	OUT_RING_QW_AGP(xl, 0xc5c, 3);
+	for (j = 0; j < 64; j += 4) {
+            OUT_RING_QW_AGP(xl, 0xc60,  
+			    ctx->chroma_non_intra_quantiser_matrix[j] |
+			    (ctx->chroma_non_intra_quantiser_matrix[j+1] << 8) |
+			    (ctx->chroma_non_intra_quantiser_matrix[j+2] << 16) |
+			    (ctx->chroma_non_intra_quantiser_matrix[j+3] << 24));
+        }
+	ctx->chromaNonIntraLoaded = 1;
+    }
+    
+    OUT_RING_QW_AGP(xl, 0xc90,  
+		    ((mb_width * mb_height) & 0x3fff) |
+		    ((control->flags & XVMC_PRED_DCT_FRAME) ? ( 1 << 14)  : 0) |
+		    ((control->flags & XVMC_TOP_FIELD_FIRST) ? (1 << 15) : 0 )  |
+		    ((control->mpeg_coding == XVMC_MPEG_2) ? (1 << 16) : 0) |
+		    ((mb_width & 0xff) << 18));
+    	
+    OUT_RING_QW_AGP(xl, 0xc94,
+		    ((control->flags & XVMC_CONCEALMENT_MOTION_VECTORS) ? 1 : 0) |
+		    ((control->flags & XVMC_Q_SCALE_TYPE) ? 2 : 0) |
+		    ((control->intra_dc_precision & 3) << 2) |
+		    (((1 + 0x100000 / mb_width) & 0xfffff) << 4) |
+		    ((control->flags & XVMC_INTRA_VLC_FORMAT) ? (1 << 24) : 0));
+
+    OUT_RING_QW_AGP(xl, 0xc98, 
+		    (((control->FHMV_range) & 0xf) << 0) |
+		    (((control->FVMV_range) & 0xf) << 4) |
+		    (((control->BHMV_range) & 0xf) << 8) |
+		    (((control->BVMV_range) & 0xf) << 12) |
+		    ((control->flags & XVMC_SECOND_FIELD) ?  (1 << 20) : 0) | 
+		    (0x0a6 << 16));
+
+}
+
+
+
+void 
+viaMpegReset(XvMCLowLevel *xl)
+{
+    int i,j;
+
+    BEGIN_HEADER6_DATA(xl, 99);
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+
+    OUT_RING_QW_AGP(xl, 0xcf0 ,0);
+
+    for (i = 0; i < 6; i++) {
+        OUT_RING_QW_AGP(xl, 0xcc0 ,0);
+        OUT_RING_QW_AGP(xl, 0xc0c, 0x43|0x20 );
+        for (j = 0xc10; j < 0xc20; j += 4)
+	        OUT_RING_QW_AGP(xl, j, 0);
+    }
+
+    OUT_RING_QW_AGP(xl, 0xc0c, 0x1c3);
+    for (j = 0xc10; j < 0xc20; j += 4)
+	    OUT_RING_QW_AGP(xl,j,0);
+
+    for (i = 0; i < 19; i++)
+        OUT_RING_QW_AGP(xl, 0xc08 ,0);
+    
+    OUT_RING_QW_AGP(xl, 0xc98, 0x400000);
+
+    for (i = 0; i < 6; i++) {
+    OUT_RING_QW_AGP(xl, 0xcc0 ,0);
+    OUT_RING_QW_AGP(xl, 0xc0c, 0x1c3|0x20);
+    for (j = 0xc10; j < 0xc20; j += 4)
+	    OUT_RING_QW_AGP(xl,j,0);
+    }
+    OUT_RING_QW_AGP(xl, 0xcf0 ,0);
+
+}
+
+void 
+viaMpegWriteSlice(XvMCLowLevel *xl, CARD8* slice, int nBytes, CARD32 sCode)
+{
+    int i, n, r;
+    CARD32* buf;
+    int count;
+
+    if (xl->errors & (LL_DECODER_TIMEDOUT |
+		      LL_IDCT_FIFO_ERROR  |
+		      LL_SLICE_FIFO_ERROR |
+		      LL_SLICE_FAULT)) return;
+
+    n = nBytes >> 2;
+    if (sCode) nBytes += 4;
+    r = nBytes & 3;
+    buf = (CARD32*) slice;
+
+    if (r) nBytes += 4 - r;
+
+    nBytes += 8;
+
+    BEGIN_HEADER6_DATA(xl, 2);
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+    OUT_RING_QW_AGP(xl, 0xc9c, nBytes);
+    
+    if (sCode) OUT_RING_QW_AGP(xl, 0xca0, sCode);
+
+    i = 0;
+    count = 0;
+
+    do {
+	count += (LL_AGP_CMDBUF_SIZE -20);
+	count = (count > n) ? n : count;
+	BEGIN_HEADER5_DATA(xl, (count - i), 0xca0);
+
+	for (; i < count; i++) {
+	    OUT_RING_AGP(xl, *buf++);
+	}
+	finish_header_agp(xl);
+    } while (i < n);
+
+    BEGIN_HEADER5_DATA(xl, 3, 0xca0);
+
+    if (r) {
+	OUT_RING_AGP(xl, *buf & ((1 << (r << 3)) - 1));
+    }
+    OUT_RING_AGP(xl,0);
+    OUT_RING_AGP(xl,0);
+    finish_header_agp(xl);
+}
+
+void 
+viaVideoSubPictureOffLocked(XvMCLowLevel *xl) {
+
+    CARD32 stride;
+    int proReg=0;
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;        
+
+    stride = VIDIN(xl,proReg|SUBP_CONTROL_STRIDE);
+#ifdef VIDEO_DMA
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+    BEGIN_HEADER6_DATA(xl,1);
+    OUT_RING_QW_AGP(xl, proReg|SUBP_CONTROL_STRIDE | 0x200, stride & ~SUBP_HQV_ENABLE);
+#else
+    pciCommand(xl, VIA_AGP_HEADER6, 1, LL_MODE_VIDEO);
+    pciCommand(xl, 0x00F60000, 0, 0);
+    pciCommand(xl, proReg|SUBP_CONTROL_STRIDE | 0x200, stride & ~SUBP_HQV_ENABLE, 0);
+    pciCommand(xl, 0, 0, 0);
+#endif
+
+}
+
+void 
+viaVideoSubPictureLocked(XvMCLowLevel *xl,ViaXvMCSubPicture *pViaSubPic) {
+
+    unsigned i;
+    CARD32 cWord;
+    
+    int proReg=0;
+    if (xl->chipId == PCI_CHIP_VT3259) proReg = REG_HQV1_INDEX;    
+
+#ifdef VIDEO_DMA
+    WAITFLAGS(xl, LL_MODE_DECODER_IDLE);
+    BEGIN_HEADER6_DATA(xl, VIA_SUBPIC_PALETTE_SIZE + 2);
+#else
+    pciCommand(xl, VIA_AGP_HEADER6, VIA_SUBPIC_PALETTE_SIZE + 2, LL_MODE_VIDEO);
+    pciCommand(xl, 0x00F60000, 0, 0);
+#endif
+    for (i=0; i<VIA_SUBPIC_PALETTE_SIZE; ++i) {
+#ifdef VIDEO_DMA
+	OUT_RING_QW_AGP(xl, proReg|RAM_TABLE_CONTROL | 0x200, pViaSubPic->palette[i]);
+#else
+	pciCommand(xl, proReg|RAM_TABLE_CONTROL | 0x200, pViaSubPic->palette[i], 0);
+#endif
+    }
+
+    cWord = (pViaSubPic->stride & SUBP_STRIDE_MASK) | SUBP_HQV_ENABLE;
+    cWord |= (pViaSubPic->ia44) ? SUBP_IA44 : SUBP_AI44;
+#ifdef VIDEO_DMA
+    OUT_RING_QW_AGP(xl, proReg|SUBP_STARTADDR | 0x200, pViaSubPic->offset);
+    OUT_RING_QW_AGP(xl, proReg|SUBP_CONTROL_STRIDE | 0x200, cWord);
+#else
+    pciCommand(xl, proReg|SUBP_STARTADDR | 0x200, pViaSubPic->offset, 0);
+    pciCommand(xl, proReg|SUBP_CONTROL_STRIDE | 0x200, cWord, 0);
+#endif
+}
+
+void 
+viaBlit(XvMCLowLevel *xl,unsigned bpp,unsigned srcBase,
+	unsigned srcPitch,unsigned dstBase,unsigned dstPitch,
+	unsigned w,unsigned h,int xdir,int ydir, unsigned blitMode, 
+	unsigned color) 
+{
+
+    CARD32 dwGEMode = 0, srcY=0, srcX, dstY=0, dstX;
+    CARD32 cmd;
+
+
+    if (!w || !h)
+        return;
+
+    finish_header_agp(xl);
+
+    switch (bpp) {
+    case 16:
+        dwGEMode |= VIA_GEM_16bpp;
+        break;
+    case 32:
+        dwGEMode |= VIA_GEM_32bpp;
+	break;
+    default:
+        dwGEMode |= VIA_GEM_8bpp;
+        break;
+    }
+
+    srcX = srcBase & 31;
+    dstX = dstBase & 31;
+    switch (bpp) {
+    case 16:
+        dwGEMode |= VIA_GEM_16bpp;
+	srcX >>= 2;
+	dstX >>= 2;
+        break;
+    case 32:
+        dwGEMode |= VIA_GEM_32bpp;
+	srcX >>= 4;
+	dstX >>= 4;
+	break;
+    default:
+        dwGEMode |= VIA_GEM_8bpp;
+        break;
+    }
+
+    BEGIN_RING_AGP(xl, 20);
+    WAITFLAGS(xl, LL_MODE_2D);
+
+
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_GEMODE), dwGEMode);
+    cmd = 0; 
+
+    if (xdir < 0) {
+        cmd |= VIA_GEC_DECX;
+        srcX += (w - 1);
+        dstX += (w - 1);
+    }
+    if (ydir < 0) {
+        cmd |= VIA_GEC_DECY;
+        srcY += (h - 1);
+        dstY += (h - 1);
+    }
+
+    switch(blitMode) {
+    case VIABLIT_TRANSCOPY:
+	OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_SRCCOLORKEY), color);
+	OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_KEYCONTROL), 0x4000);
+	cmd |= VIA_GEC_BLT | (VIA_BLIT_COPY << 24);
+	break;
+    case VIABLIT_FILL:
+	OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_FGCOLOR), color);
+	cmd |= VIA_GEC_BLT | VIA_GEC_FIXCOLOR_PAT | (VIA_BLIT_FILL << 24);
+	break;
+    default:
+	OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_KEYCONTROL), 0x0);
+	cmd |= VIA_GEC_BLT | (VIA_BLIT_COPY << 24);
+    }	
+
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_SRCBASE), (srcBase & ~31) >> 3);
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_DSTBASE), (dstBase & ~31) >> 3);
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_PITCH), VIA_PITCH_ENABLE |
+		    (srcPitch >> 3) | (((dstPitch) >> 3) << 16));
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_SRCPOS), ((srcY << 16) | srcX));
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_DSTPOS), ((dstY << 16) | dstX));
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_DIMENSION), (((h - 1) << 16) | (w - 1)));
+    OUT_RING_QW_AGP(xl, H1_ADDR(VIA_REG_GECMD), cmd);
+}
+
+unsigned 
+syncXvMCLowLevel(XvMCLowLevel *xl, unsigned int mode, unsigned int doSleep,
+		 CARD32 timeStamp)
+{
+    unsigned
+	errors;
+
+    if (mode == 0) {
+	errors = xl->errors;
+	xl->errors = 0;
+	return errors;
+    }
+
+    if ((mode & (LL_MODE_VIDEO | LL_MODE_3D)) || !xl->use_agp) {
+	if (xl->performLocking) 
+	    hwlLock(xl,0);
+	if ((mode != LL_MODE_VIDEO))
+	    syncDMA(xl, doSleep);
+	if (mode & LL_MODE_3D) 
+	    syncAccel(xl, mode, doSleep);
+	if (mode & LL_MODE_VIDEO)
+	    syncVideo(xl, doSleep);
+	if (xl->performLocking) 
+	    hwlUnlock(xl,0);
+    } else {
+	viaDMAWaitTimeStamp(xl, timeStamp, doSleep);
+    }
+
+    if (mode & (LL_MODE_DECODER_SLICE | LL_MODE_DECODER_IDLE)) 
+	syncMpeg(xl, mode, doSleep);
+
+    errors = xl->errors;
+    xl->errors = 0;
+
+    return errors;
+}
+
+int 
+initXvMCLowLevel(XvMCLowLevel *xl, int fd, drm_context_t *ctx,
+		 drmLockPtr hwLock, drmAddress mmioAddress, 
+		 drmAddress fbAddress, int useAgp, unsigned chipId ) 
+{
+    xl->agp_pos = 0;
+    xl->pci_pos = 0;
+    xl->use_agp = useAgp;
+    xl->fd = fd;
+    xl->drmcontext = ctx;
+    xl->hwLock = hwLock;
+    xl->mmioAddress = mmioAddress;
+    xl->fbAddress = fbAddress;
+    xl->curWaitFlags = 0;
+    xl->performLocking = 1;
+    xl->errors = 0;
+    xl->agpSync = 0;
+    xl->agp_mode = 0;
+    xl->chipId = chipId;
+    return viaDMAInitTimeStamp(xl); 
+
+}
+
+void 
+setLowLevelLocking(XvMCLowLevel *xl, int performLocking)
+{
+    xl->performLocking = performLocking;
+}
+
+void 
+closeXvMCLowLevel(XvMCLowLevel *xl) 
+{
+    viaDMACleanupTimeStamp(xl); 
+}
+
diff -Naur libxvmc-20050514-old/viaXvMC.c libxvmc-20050514-new/viaXvMC.c
--- libxvmc-20050514-old/viaXvMC.c	2005-03-14 15:38:50.000000000 -0800
+++ libxvmc-20050514-new/viaXvMC.c	2005-05-15 10:24:02.417294305 -0700
@@ -43,6 +43,8 @@
 #include <xf86drm.h>
 #include <pthread.h>
 #include "vldXvMC.h"
+#include "xf86dri.h"
+#include "driDrawable.h"
     
 #define SAREAPTR(ctx) ((ViaXvMCSAreaPriv *)			\
 		       (((CARD8 *)(ctx)->sAreaAddress) +	\
@@ -52,11 +54,14 @@
 
 static int error_base;
 static int event_base;
+static unsigned numContexts = 0;
+static int globalFD;
+static drmAddress sAreaAddress;
+static drmAddress fbAddress;
+static drmAddress mmioAddress;
 
 
 #define FOURCC_XVMC (('C' << 24) + ('M' << 16) + ('V' << 8) + 'X')
-#define XVMC_DECODER_FUTEX(sAPriv) \
-  XVMCLOCKPTR(sAPriv, UNICHROME_LOCK_DECODER1)
 
 static unsigned yOffs (ViaXvMCSurface *srf) 
 {
@@ -100,33 +105,14 @@
     volatile ViaXvMCSAreaPriv *sAPriv;
 
     sAPriv = SAREAPTR(ctx);
-
-    if ((XVMCLOCKPTR(sAPriv,UNICHROME_LOCK_DECODER1)->lock & ~DRM_LOCK_CONT) == 
-	(ctx->drmcontext | DRM_LOCK_HELD)) {
-	DRM_CAS_RESULT(__ret);
-
-	if (clearCtx)
-	    sAPriv->XvMCCtxNoGrabbed = ~0;
-	
-	DRM_CAS( XVMC_DECODER_FUTEX(sAPriv), ctx->drmcontext | DRM_LOCK_HELD,
-		 0, __ret);
-	if (__ret) {
-	    drm_via_futex_t fx;
-	    fx.func = VIA_FUTEX_WAKE;
-	    fx.lock = 0;
-	    XVMC_DECODER_FUTEX(sAPriv)->lock = 0;
-	    drmCommandWrite(ctx->fd, DRM_VIA_DEC_FUTEX, &fx, sizeof(fx));
-	    sched_yield();
-	}
-    }
-
+    UNICHROME_UNLOCK(ctx->fd, UNICHROME_LOCK_DECODER1, sAPriv, ctx->drmcontext);
 }
 
 
 static int grabDecoder(	ViaXvMCContext *ctx, int *hadLastLock) 
 {
     volatile ViaXvMCSAreaPriv *sAPriv =  SAREAPTR(ctx);
-    int retFtx;
+    int retFtx, lc;
 
     /*
      * Try to grab the decoder. If it is not available we will sleep until
@@ -136,88 +122,17 @@
      */
 
     if (ctx->haveDecoder) {
-        fprintf(stderr,"ViaXvMC: ERROR: Trying to re-lock decoder.\n");
+        flushXvMCLowLevel(&ctx->xl);  /* Ignore errors here. */
+	/*
+	  fprintf(stderr,"ViaXvMC: ERROR: Trying to re-lock decoder.\n"); */
 	*hadLastLock = 1;
         return 0;
     }
+    UNICHROME_LOCK(ctx->fd, UNICHROME_LOCK_DECODER1, sAPriv, ctx->drmcontext, lc,
+		   retFtx);
+    *hadLastLock = (ctx->drmcontext == lc);
 
-    while(1) {
-	DRM_CAS_RESULT(__ret);
-	DRM_CAS( XVMC_DECODER_FUTEX(sAPriv), 0, 
-		 ctx->drmcontext | DRM_LOCK_HELD,__ret);
-
-	if (__ret) {
-
-	    drm_via_futex_t fx;
-	    int lockVal;
-
-	    /*
-	     * The decoder is locked. Try to 
-	     * mark the lock as contended and go to 
-	     * sleep.
-	     */
-
-	    lockVal =  XVMC_DECODER_FUTEX(sAPriv)->lock;
-
-	    if (!(lockVal & DRM_LOCK_HELD)) continue;
-	    if ((lockVal & ~(DRM_LOCK_HELD | DRM_LOCK_CONT)) == 
-		ctx->drmcontext) {
-		*hadLastLock = 1;
-		return 0;
-	    }
-	    fx.val = lockVal | DRM_LOCK_CONT;
-	    DRM_CAS( XVMC_DECODER_FUTEX(sAPriv), lockVal, fx.val , __ret); 
-	    lockVal =  XVMC_DECODER_FUTEX(sAPriv)->lock;
-
-	    if (__ret) continue;
-
-	    fx.func = VIA_FUTEX_WAIT;
-	    fx.lock = 0;
-	    fx.ms = 10;
-	    pthread_mutex_unlock( &ctx->ctxMutex );
-	    if (0 != (retFtx = 
-		      drmCommandWrite(ctx->fd,DRM_VIA_DEC_FUTEX, &fx, 
-				      sizeof(fx)))) {
-		switch(retFtx) {
-		case -EBUSY:
-		    return 1;
-		case -EINVAL:
-		{
-		    /*
-		     * DRM does not support the futex IOCTL. Sleep.
-		     */
-
-		    struct timespec
-			sleep,rem;
-
-		    sleep.tv_nsec = 1;
-		    sleep.tv_sec = 0;
-		    nanosleep(&sleep,&rem);
-		    break;
-		}
-		default:
-		    break;
-		}
-	    } 
-	    pthread_mutex_lock( &ctx->ctxMutex );
-	} else {
-
-	    /*
-	     * The decoder is available. Mark it as used, check if we were
-	     * the one who had it locked last time and return. 
-	     */
-
-	    *hadLastLock = (sAPriv->XvMCCtxNoGrabbed == ctx->drmcontext);
-	    sAPriv->XvMCCtxNoGrabbed = ctx->drmcontext;
-	    return 0;
-	}
-    }
-
-    /*
-     * We should never get here.
-     */
-
-    return 0;
+    return retFtx;
 }
 	    
 static void setupAttribDesc(Display *display, XvPortID port,
@@ -266,24 +181,38 @@
     ViaXvMCContext *pViaXvMC = (ViaXvMCContext *) context->privData;
 
     switch(pViaXvMC->resources) {
+    case context_drawHash:
+        driDestroyHashContents( pViaXvMC->drawHash );
+	drmHashDestroy( pViaXvMC->drawHash );
     case context_lowLevel:
 	closeXvMCLowLevel(&pViaXvMC->xl);
     case context_mutex:
 	pthread_mutex_destroy(&pViaXvMC->ctxMutex);
+    case context_drmContext:
+	XF86DRIDestroyContext(display, pViaXvMC->screen, pViaXvMC->id);
     case context_sAreaMap:
-	drmUnmap(pViaXvMC->sAreaAddress,pViaXvMC->sAreaSize);
+	numContexts--;
+	if (numContexts == 0)
+	    drmUnmap(pViaXvMC->sAreaAddress,pViaXvMC->sAreaSize);
     case context_fbMap:
-	drmUnmap(pViaXvMC->fbAddress,pViaXvMC->fbSize);
+	if (numContexts == 0)
+	    drmUnmap(pViaXvMC->fbAddress,pViaXvMC->fbSize);
     case context_mmioMap:
-	drmUnmap(pViaXvMC->mmioAddress,pViaXvMC->mmioSize);
+	if (numContexts == 0)
+	    drmUnmap(pViaXvMC->mmioAddress,pViaXvMC->mmioSize);
+    case context_fd:
+	if (numContexts == 0) {
+	    if (pViaXvMC->fd >= 0)
+		drmClose(pViaXvMC->fd);
+	}
+	pViaXvMC->fd = -1;
+    case context_driConnection:
+	if (numContexts == 0)
+	    XF86DRICloseConnection(display, pViaXvMC->screen);
     case context_context:
 	XLockDisplay(display);
 	_xvmc_destroy_context(display, context);
 	XUnlockDisplay(display);
-    case context_fd:
-	if (pViaXvMC->fd >= 0)
-	    drmClose(pViaXvMC->fd);
-	pViaXvMC->fd = -1;
 	if (!freePrivate) break;
     default:
 	free(pViaXvMC);
@@ -291,6 +220,23 @@
     return errType;
 }
 
+static void
+setRegion(unsigned x,unsigned y, unsigned w, unsigned h, XvMCRegion *region)
+{
+    region->x = x;
+    region->y = y;
+    region->w = w;
+    region->h = h;
+}
+
+static int
+regionEqual(const XvMCRegion *r1, const XvMCRegion *r2)
+{
+    return (r1->x == r2->x &&
+	    r1->y == r2->y &&
+	    r1->w == r2->w &&
+	    r1->h == r2->h);
+}
 
 Status XvMCCreateContext(Display *display, XvPortID port,
 			 int surface_type_id, int width, int height, int flags,
@@ -305,7 +251,8 @@
     int major, minor;
     ViaXvMCCreateContextRec *tmpComm;
     drmVersionPtr drmVer;
-    char curBusID[20];
+    char *curBusID;
+    int isCapable;
 
     /* 
      * Verify Obvious things first 
@@ -360,168 +307,198 @@
     ret = XvMCQueryVersion(display, &major, &minor);
     if(ret) {
 	fprintf(stderr,"XvMCQuery Version Failed, unable to determine "
-		"protocol version\n");
+		"protocol version!\n");
     }
     XUnlockDisplay(display);
 
     /* FIXME: Check Major and Minor here */
 
-    /* Check for drm */
+    XLockDisplay(display);
+    if((ret = _xvmc_create_context(display, context, &priv_count, 
+				       &priv_data))) {
+      XUnlockDisplay(display);
+      fprintf(stderr,"Unable to create XvMC Context.\n");
+      return releaseContextResources(display, context, 1, BadAlloc);
+    }
+    XUnlockDisplay(display);
+
+    /*
+     * Check size and version of returned data.
+     */
 
-    if(! drmAvailable()) {
-	fprintf(stderr,"Direct Rendering is not avilable on this system!\n");
+    tmpComm = (  ViaXvMCCreateContextRec *) priv_data;
+    if(priv_count != (sizeof(ViaXvMCCreateContextRec) >> 2)) {
+	fprintf(stderr,"_xvmc_create_context() returned incorrect "
+		"data size!\n");
+	fprintf(stderr,"\tExpected %d, got %d\n",
+		(sizeof(ViaXvMCCreateContextRec) >> 2),
+		priv_count);
+	XFree(priv_data);
 	return releaseContextResources(display, context, 1, BadAlloc);
     }
+    pViaXvMC->resources = context_context;
 
-    /*
-     * We don't know the BUSID. Have the X server tell it to us by faking
-     * a working drm connection.
-     */ 
+    if ((tmpComm->major != VIAXVMC_MAJOR) ||
+	(tmpComm->minor != VIAXVMC_MINOR)) {
+	fprintf(stderr,"Version mismatch between the X via driver\n"
+		"and the XvMC library. Cannot continue!\n");
+	XFree(priv_data);
+	return releaseContextResources(display, context, 1, BadAlloc);
+    }
 
-    strncpy(curBusID,"NOBUSID",20);
-    pViaXvMC->fd = -1;
+    pViaXvMC->ctxNo = tmpComm->ctxNo;
+    pViaXvMC->fbOffset = tmpComm->fbOffset;
+    pViaXvMC->fbSize = tmpComm->fbSize;
+    pViaXvMC->mmioOffset = tmpComm->mmioOffset;
+    pViaXvMC->mmioSize = tmpComm->mmioSize;
+    pViaXvMC->sAreaSize = tmpComm->sAreaSize;
+    pViaXvMC->sAreaPrivOffset = tmpComm->sAreaPrivOffset;
+    pViaXvMC->decoderOn = 0;
+    pViaXvMC->xvMCPort = tmpComm->xvmc_port;
+    pViaXvMC->useAGP = tmpComm->useAGP;
+    pViaXvMC->attrib = tmpComm->initAttrs;
+    pViaXvMC->screen = tmpComm->screen;
+    pViaXvMC->depth = tmpComm->depth;
+    pViaXvMC->stride = tmpComm->stride;
+    pViaXvMC->chipId = tmpComm->chipId;
 
-    do {
-	if (strcmp(curBusID,"NOBUSID")) {
-	    if((pViaXvMC->fd = drmOpen("via",curBusID)) < 0) {
-		fprintf(stderr,"DRM Device for via could not be opened.\n");
-		return releaseContextResources(display, context, 1, BadAlloc);
-	    }
-	    pViaXvMC->resources = context_fd;
+    /* 
+     * Must free the private data we were passed from X 
+     */
 
-	    if (NULL == (drmVer = drmGetVersion(pViaXvMC->fd))) {
-		fprintf(stderr, 
-			"viaXvMC: Could not get drm version.");
-		return releaseContextResources(display, context, 1, BadAlloc);
-	    }
-	    if (((drmVer->version_major != 2 ) || (drmVer->version_minor < 0))) {
-		fprintf(stderr, 
-			"viaXvMC: Kernel drm is not compatible with XvMC.\n"); 
-		fprintf(stderr, 
-			"viaXvMC: Kernel drm version: %d.%d.%d "
-			"and I need at least version 2.0.0.\n"
-			"Please update.\n",
-			drmVer->version_major,drmVer->version_minor,
-			drmVer->version_patchlevel); 
-		drmFreeVersion(drmVer);
-		return releaseContextResources(display, context, 1, BadAlloc);
-	    } 
-	    drmFreeVersion(drmVer);
-	    drmGetMagic(pViaXvMC->fd,&magic);
-	} else {
-	    magic = 0;
-	}
-	context->flags = (unsigned long)magic;
+    XFree(priv_data);
 
-	/*
-	 * Pass control to the X server to create a drmContext for us, and
-	 * validate the width / height and flags.
-	 */
+    /*
+     * Check for direct rendering capable, establish DRI and DRM connections,
+     * map framebuffer, DRI shared area and read-only register areas. 
+     * Initial checking for drm has already been done by the server. 
+     * Only do this for the first context we create.
+     */ 
 
-	XLockDisplay(display);
-	if((ret = _xvmc_create_context(display, context, &priv_count, 
-				       &priv_data))) {
-	    XUnlockDisplay(display);
-	    fprintf(stderr,"Unable to create XvMC Context.\n");
+    if (numContexts == 0) {
+	ret = XF86DRIQueryDirectRenderingCapable(display, pViaXvMC->screen, &isCapable);
+	if (!ret || !isCapable) {
+	    fprintf(stderr,"Direct Rendering is not available on this system!\n");
 	    return releaseContextResources(display, context, 1, BadAlloc);
 	}
-	XUnlockDisplay(display);
 
-	if(priv_count != (sizeof(ViaXvMCCreateContextRec) >> 2)) {
-	    fprintf(stderr,"_xvmc_create_context() returned incorrect "
-		    "data size!\n");
-	    fprintf(stderr,"\tExpected %d, got %d\n",
-		    (sizeof(ViaXvMCCreateContextRec) >> 2),
-		    priv_count);
+	if (!XF86DRIOpenConnection(display, pViaXvMC->screen, &pViaXvMC->sAreaOffset,
+				   &curBusID)) {
+	    fprintf(stderr,"Could not open DRI connection to X server!\n");
 	    return releaseContextResources(display, context, 1, BadAlloc);
-	}
-	pViaXvMC->resources = context_context;
+	}	
+	strncpy(pViaXvMC->busIdString,curBusID,20);
+	pViaXvMC->busIdString[20] = '\0';    
+	XFree(curBusID);
 
-	tmpComm = (  ViaXvMCCreateContextRec *) priv_data;
+	pViaXvMC->resources = context_driConnection;    
 
-	if ((tmpComm->major != VIAXVMC_MAJOR) ||
-	    (tmpComm->minor != VIAXVMC_MINOR)) {
-	    fprintf(stderr,"Version mismatch between the XFree86 via driver\n"
-		    "and the XvMC library. Cannot continue!\n");
+	if((pViaXvMC->fd = drmOpen("via",curBusID)) < 0) {
+	    fprintf(stderr,"DRM Device for via could not be opened.\n");
 	    return releaseContextResources(display, context, 1, BadAlloc);
 	}
-      
-	if (strncmp(curBusID, tmpComm->busIdString, 20)) {
-	    releaseContextResources(display, context, 0, Success);
-	    pViaXvMC->resources = context_none;
-	    strncpy(curBusID, tmpComm->busIdString, 20);
-	    XFree(priv_data);
-	    continue;
+	globalFD = pViaXvMC->fd;
+	pViaXvMC->resources = context_fd;
+
+	if (NULL == (drmVer = drmGetVersion(pViaXvMC->fd))) {
+	    fprintf(stderr, 
+		    "viaXvMC: Could not get drm version.");
+	    return releaseContextResources(display, context, 1, BadAlloc);
 	}
-      
-	if (!tmpComm->authenticated) {
+	if (((drmVer->version_major != 2 ) || (drmVer->version_minor < 0))) {
+	    fprintf(stderr, 
+		    "viaXvMC: Kernel drm is not compatible with XvMC.\n"); 
+	    fprintf(stderr, 
+		    "viaXvMC: Kernel drm version: %d.%d.%d "
+		    "and I need at least version 2.0.0.\n"
+		    "Please update.\n",
+		    drmVer->version_major,drmVer->version_minor,
+		    drmVer->version_patchlevel); 
+	    drmFreeVersion(drmVer);
+	    return releaseContextResources(display, context, 1, BadAlloc);
+	} 
+	drmFreeVersion(drmVer);
+	drmGetMagic(pViaXvMC->fd,&magic);
+	
+	if (!XF86DRIAuthConnection(display, pViaXvMC->screen, magic)) {
+	    fprintf(stderr, "viaXvMC: X server did not allow DRI. Check permissions.\n");
 	    XFree(priv_data);
 	    return releaseContextResources(display, context, 1, BadAlloc);
 	}
-	    
-    } while (pViaXvMC->fd < 0);
 
-    pViaXvMC->ctxNo = tmpComm->ctxNo;
-    pViaXvMC->drmcontext = tmpComm->drmcontext;
-    pViaXvMC->fbOffset = tmpComm->fbOffset;
-    pViaXvMC->fbSize = tmpComm->fbSize;
-    pViaXvMC->mmioOffset = tmpComm->mmioOffset;
-    pViaXvMC->mmioSize = tmpComm->mmioSize;
-    pViaXvMC->sAreaOffset = tmpComm->sAreaOffset;
-    pViaXvMC->sAreaSize = tmpComm->sAreaSize;
-    pViaXvMC->sAreaPrivOffset = tmpComm->sAreaPrivOffset;
-    pViaXvMC->decoderOn = 0;
-    pViaXvMC->xvMCPort = tmpComm->xvmc_port;
-    pViaXvMC->useAGP = tmpComm->useAGP;
-    for (i=0; i<VIA_MAX_RENDSURF; ++i) {
-	pViaXvMC->rendSurf[i] = 0;
-    }
-    strncpy(pViaXvMC->busIdString,tmpComm->busIdString,20);
-    pViaXvMC->busIdString[20] = '\0';    
-    pViaXvMC->attrib = tmpComm->initAttrs;
-    pViaXvMC->lastSrfDisplaying = ~0;
-    setupAttribDesc(display, port, &pViaXvMC->attrib, pViaXvMC->attribDesc);
+	/* 
+	 * Map the register memory 
+	 */
 
-    /* 
-     * Must free the private data we were passed from X 
-     */
+	if(drmMap(pViaXvMC->fd,pViaXvMC->mmioOffset,
+		  pViaXvMC->mmioSize,&mmioAddress) < 0) {
+	    fprintf(stderr,"Unable to map the display chip mmio registers.\n");
+	    return releaseContextResources(display, context, 1, BadAlloc);
+	}   
+	pViaXvMC->mmioAddress = mmioAddress;
+	pViaXvMC->resources = context_mmioMap;
 
-    XFree(priv_data);
-    
-    /* 
-     * Map the register memory 
-     */
+	/* 
+	 * Map Framebuffer memory 
+	 */
 
-    if(drmMap(pViaXvMC->fd,pViaXvMC->mmioOffset,
-	      pViaXvMC->mmioSize,&(pViaXvMC->mmioAddress)) < 0) {
-	fprintf(stderr,"Unable to map the display chip mmio registers.\n");
-	return releaseContextResources(display, context, 1, BadAlloc);
-    }   
-    pViaXvMC->resources = context_mmioMap;
+	if(drmMap(pViaXvMC->fd,pViaXvMC->fbOffset,
+		  pViaXvMC->fbSize,&fbAddress) < 0) {
+	    fprintf(stderr,"Unable to map XvMC Framebuffer.\n");
+	    return releaseContextResources(display, context, 1, BadAlloc);
+	} 
+	pViaXvMC->fbAddress = fbAddress;
+	pViaXvMC->resources = context_fbMap;
 
-    /* 
-     * Map Framebuffer memory 
-     */
 
-    if(drmMap(pViaXvMC->fd,pViaXvMC->fbOffset,
-	      pViaXvMC->fbSize,&(pViaXvMC->fbAddress)) < 0) {
-	fprintf(stderr,"Unable to map XvMC Framebuffer.\n");
-	return releaseContextResources(display, context, 1, BadAlloc);
-    } 
-    pViaXvMC->resources = context_fbMap;
+	/*
+	 * Map DRI Sarea.
+	 */
 
+	if(drmMap(pViaXvMC->fd,pViaXvMC->sAreaOffset,
+		  pViaXvMC->sAreaSize,&sAreaAddress) < 0) {
+	    fprintf(stderr,"Unable to map DRI SAREA.\n");
+	    return releaseContextResources(display, context, 1, BadAlloc);
+	} 
+    } else {
+	pViaXvMC->fd = globalFD;
+	pViaXvMC->mmioAddress = mmioAddress;
+	pViaXvMC->fbAddress = fbAddress;
+    }
+
+    pViaXvMC->sAreaAddress = sAreaAddress;
+    pViaXvMC->resources = context_sAreaMap;
+    numContexts++;
 
     /*
-     * Map XvMC Sarea and get the address of the HW lock.
+     * Find a matching visual. Important only for direct drawing to the visible
+     * frame-buffer.
      */
 
-    if(drmMap(pViaXvMC->fd,pViaXvMC->sAreaOffset,
-	      pViaXvMC->sAreaSize,&(pViaXvMC->sAreaAddress)) < 0) {
-	fprintf(stderr,"Unable to map DRI SAREA.\n");
+    XLockDisplay(display);
+    ret = XMatchVisualInfo(display, pViaXvMC->screen, 
+			   (pViaXvMC->depth == 32) ? 24 : pViaXvMC->depth, TrueColor, 
+			   &pViaXvMC->visualInfo);
+    XUnlockDisplay(display);
+    if (!ret) {
+	fprintf(stderr, "viaXvMC: Could not find a matching TrueColor visual.\n");
 	return releaseContextResources(display, context, 1, BadAlloc);
-    } 
-    pViaXvMC->resources = context_sAreaMap;
+    }	
+
+    if (!XF86DRICreateContext(display, pViaXvMC->screen, pViaXvMC->visualInfo.visual, 
+			      &pViaXvMC->id, &pViaXvMC->drmcontext)) {
+	
+	fprintf(stderr, "viaXvMC: Could not create DRI context.\n");
+	return releaseContextResources(display, context, 1, BadAlloc);
+    }
+
+    pViaXvMC->resources = context_drmContext;
 
+    for (i=0; i<VIA_MAX_RENDSURF; ++i) {
+	pViaXvMC->rendSurf[i] = 0;
+    }
+    pViaXvMC->lastSrfDisplaying = ~0;
+    setupAttribDesc(display, port, &pViaXvMC->attrib, pViaXvMC->attribDesc);
 
     pViaXvMC->hwLock = (drmLockPtr) pViaXvMC->sAreaAddress;
     defaultQMatrices(pViaXvMC);
@@ -535,21 +512,34 @@
     pthread_mutex_init(&pViaXvMC->ctxMutex,NULL);
     pViaXvMC->resources = context_mutex;
     pViaXvMC->timeStamp = 0;
+    setRegion(0,0,-1,-1,&pViaXvMC->sRegion);
+    setRegion(0,0,-1,-1,&pViaXvMC->dRegion);
 
     if (initXvMCLowLevel(&pViaXvMC->xl, pViaXvMC->fd, &pViaXvMC->drmcontext,
 			 pViaXvMC->hwLock, pViaXvMC->mmioAddress, 
-			 pViaXvMC->fbAddress, pViaXvMC->useAGP)) {
-	fprintf(stderr,"ViaXvMC: Could not allocate timestamp blit area\n");
+			 pViaXvMC->fbAddress, pViaXvMC->useAGP, pViaXvMC->chipId)) {
+	fprintf(stderr,"ViaXvMC: Could not allocate timestamp blit area.\n");
 	return releaseContextResources(display, context, 1, BadAlloc);
     }       
     pViaXvMC->resources = context_lowLevel;
     setAGPSyncLowLevel(&pViaXvMC->xl, 1, 0);
-    hwlLock(&pViaXvMC->xl,1); 
-    setLowLevelLocking(&pViaXvMC->xl,0);
-    viaVideoSubPictureOffLocked(&pViaXvMC->xl); 
-    flushXvMCLowLevel(&pViaXvMC->xl);  /* Ignore errors here. */
-    setLowLevelLocking(&pViaXvMC->xl,1);
-    hwlUnlock(&pViaXvMC->xl,1); 
+    
+    if (NULL == (pViaXvMC->drawHash = drmHashCreate())) {
+	fprintf(stderr,"ViaXvMC: Could not allocate drawable hash table.\n");
+	return releaseContextResources(display, context, 1, BadAlloc);
+    }   
+    pViaXvMC->resources = context_drawHash;
+
+
+    if (numContexts == 1) {
+	hwlLock(&pViaXvMC->xl,1); 
+	setLowLevelLocking(&pViaXvMC->xl,0);
+	viaVideoSubPictureOffLocked(&pViaXvMC->xl);
+	flushXvMCLowLevel(&pViaXvMC->xl);  
+	setLowLevelLocking(&pViaXvMC->xl,1);
+	hwlUnlock(&pViaXvMC->xl,1);
+    }
+
     return Success;
 }
 
@@ -566,7 +556,6 @@
 	return (error_base + XvMCBadContext);
     }
 
-
     /*
      * Release decoder if we have it. In case of crash or termination
      * before XvMCDestroyContext, the X server will take care of this.
@@ -685,7 +674,8 @@
     }
 
     viaMpegWriteSlice(&pViaXvMC->xl, (CARD8 *)slice, nBytes, sCode);
-    flushPCIXvMCLowLevel(&pViaXvMC->xl);
+
+    flushPCIXvMCLowLevel(&pViaXvMC->xl); 
     pthread_mutex_unlock( &pViaXvMC->ctxMutex );
     return Success;
 }
@@ -760,6 +750,7 @@
     return Success;
 }
 
+
 Status XvMCPutSurface(Display *display,XvMCSurface *surface,Drawable draw,
 		      short srcx, short srcy, unsigned short srcw, 
 		      unsigned short srch,short destx,short desty,
@@ -784,6 +775,9 @@
     Status ret;
     unsigned dispSurface, lastSurface;
     int overlayUpdated;
+    drawableInfo *drawInfo;
+    XvMCRegion sReg, dReg;
+    Bool forceUpdate = FALSE;
 
     if((display == NULL) || (surface == NULL)) {
 	return BadValue;
@@ -798,8 +792,37 @@
     pthread_mutex_lock( &pViaXvMC->ctxMutex );
     pViaSubPic = pViaSurface->privSubPic;
     sAPriv = SAREAPTR( pViaXvMC );
-    hwlLock(&pViaXvMC->xl,1); 
+
+    setRegion(srcx, srcy, srcw, srch, &sReg);
+    setRegion(destx, desty, destw, desth, &dReg);
+    
+    if ((!regionEqual(&sReg, &pViaXvMC->sRegion)) ||
+	(!regionEqual(&dReg, &pViaXvMC->dRegion))) {
+    
+	/*
+	 * Force update of the video overlay to match the new format.
+	 */
+
+	pViaXvMC->sRegion = sReg;
+	pViaXvMC->dRegion = dReg;
+	forceUpdate = TRUE;
+    }
+    
+
+    hwlLock(&pViaXvMC->xl,1);
     
+    if (getDRIDrawableInfoLocked(pViaXvMC->drawHash, display, pViaXvMC->screen, draw, 0,
+				 pViaXvMC->fd, pViaXvMC->drmcontext, pViaXvMC->sAreaAddress, 
+				 FALSE, &drawInfo, sizeof(*drawInfo))) {
+
+	hwlUnlock(&pViaXvMC->xl,1);
+	pthread_mutex_unlock( &pViaXvMC->ctxMutex );
+	return BadAccess;
+    }
+
+    setLowLevelLocking(&pViaXvMC->xl,0);
+	
+
     /*
      * Put a surface ID in the SAREA to "authenticate" to the 
      * X server.
@@ -814,14 +837,17 @@
     viaVideoSetSWFLipLocked(&pViaXvMC->xl, yOffs(pViaSurface), uOffs(pViaSurface), 
 			    vOffs(pViaSurface));
 
-    if (lastSurface != dispSurface) {
+    while ((lastSurface != dispSurface) || forceUpdate) {
+
+	forceUpdate = FALSE;
+	flushPCIXvMCLowLevel(&pViaXvMC->xl);
+	setLowLevelLocking(&pViaXvMC->xl,1);
 	hwlUnlock(&pViaXvMC->xl,1);
 
 	/*
 	 * We weren't the last to display. Update the overlay before flipping.
 	 */
 
-	flushPCIXvMCLowLevel(&pViaXvMC->xl);
 	ret = updateXVOverlay(display,pViaXvMC,pViaSurface,draw,srcx,srcy,srcw, 
 			      srch,destx,desty,destw,desth);
 	if (ret) {
@@ -830,19 +856,22 @@
 	}
 
 	hwlLock(&pViaXvMC->xl,1);
-	overlayUpdated = 1;
-	if (pViaXvMC->lastSrfDisplaying != sAPriv->XvMCDisplaying[pViaXvMC->xvMCPort]) {
 
-	    /*
-	     * Race. Somebody beat us to the port.
-	     */
-	  
+	if (getDRIDrawableInfoLocked(pViaXvMC->drawHash, display, pViaXvMC->screen, draw, 0,
+				     pViaXvMC->fd, pViaXvMC->drmcontext, pViaXvMC->sAreaAddress, 
+				     FALSE, &drawInfo, sizeof(*drawInfo))) {
+	    
 	    hwlUnlock(&pViaXvMC->xl,1);
 	    pthread_mutex_unlock( &pViaXvMC->ctxMutex );
 	    return BadAccess;
 	}
+	
+	setLowLevelLocking(&pViaXvMC->xl,0);
+	lastSurface = pViaSurface->srfNo | VIA_XVMC_VALID;
+	dispSurface = sAPriv->XvMCDisplaying[pViaXvMC->xvMCPort];
+	overlayUpdated = 1;
     } 
-    setLowLevelLocking(&pViaXvMC->xl,0);
+
 
     /*
      * Subpictures
@@ -867,11 +896,12 @@
      */
 
     viaVideoSWFlipLocked(&pViaXvMC->xl, flags, pViaSurface->progressiveSequence);
-    flushPCIXvMCLowLevel(&pViaXvMC->xl);
+    flushXvMCLowLevel(&pViaXvMC->xl);  
+
     setLowLevelLocking(&pViaXvMC->xl,1);
     hwlUnlock(&pViaXvMC->xl,1);
 
-    if (overlayUpdated) {
+    if (overlayUpdated || !drawInfo->touched ) {
         pthread_mutex_unlock( &pViaXvMC->ctxMutex );
 	return Success;
     }
@@ -939,8 +969,9 @@
 	    timeStamp = viaDMATimeStampLowLevel(&pViaXvMC->xl);
 	    if (flushXvMCLowLevel(&pViaXvMC->xl)) {
 	        releaseDecoder(pViaXvMC, 0);
+		pthread_mutex_unlock( &pViaXvMC->ctxMutex );
 		return BadAlloc;
-	    }	      
+	    } 	      
 	    pViaXvMC->timeStamp = timeStamp;
 	} else {
 	    timeStamp = pViaXvMC->timeStamp;
@@ -974,19 +1005,21 @@
     targS->progressiveSequence = (control->flags & XVMC_PROGRESSIVE_SEQUENCE); 
     targS->privSubPic = NULL;
     
-    viaMpegSetFB(&pViaXvMC->xl,0,yOffs(targS),uOffs(targS),vOffs(targS));
     viaMpegSetSurfaceStride(&pViaXvMC->xl,pViaXvMC);
+
+    viaMpegSetFB(&pViaXvMC->xl,0,yOffs(targS),uOffs(targS),vOffs(targS));
     if (past_surface) {
 	viaMpegSetFB(&pViaXvMC->xl,1,yOffs(pastS),uOffs(pastS),vOffs(pastS));
     } else {
-	viaMpegSetFB(&pViaXvMC->xl,1,0xffffffff,0xffffffff,0xffffffff);
+	viaMpegSetFB(&pViaXvMC->xl,1,0,0,0);
     }
     
     if (future_surface) {
 	viaMpegSetFB(&pViaXvMC->xl,2,yOffs(futS),uOffs(futS),vOffs(futS));
     } else {
-	viaMpegSetFB(&pViaXvMC->xl,2,0xffffffff,0xffffffff,0xffffffff);
+	viaMpegSetFB(&pViaXvMC->xl,2,0,0,0);
     }
+
     viaMpegBeginPicture(&pViaXvMC->xl,pViaXvMC,context->width,context->height,control);
     flushPCIXvMCLowLevel(&pViaXvMC->xl);
     targS->needsSync = 1;
@@ -1528,13 +1561,29 @@
 	    yOffs(pViaSurface), pViaSurface->yStride,
 	    width, height, 1, 1, VIABLIT_COPY, 0);
     flushPCIXvMCLowLevel(&pViaXvMC->xl);
-    viaBlit(&pViaXvMC->xl, 8, uOffs(pViaSSurface), pViaSSurface->yStride >> 1,
-	    uOffs(pViaSurface), pViaSurface->yStride >> 1,
-	    width >> 1, height >> 1, 1, 1, VIABLIT_COPY, 0);
-    flushPCIXvMCLowLevel(&pViaXvMC->xl);
-    viaBlit(&pViaXvMC->xl, 8, vOffs(pViaSSurface), pViaSSurface->yStride >> 1,
-	    vOffs(pViaSurface), pViaSurface->yStride >> 1,
-	    width >> 1, height >> 1, 1, 1, VIABLIT_COPY, 0);
+    if (pViaXvMC->chipId != PCI_CHIP_VT3259) {
+
+	/*
+	 * YV12 Chroma blit.
+	 */
+	
+	viaBlit(&pViaXvMC->xl, 8, uOffs(pViaSSurface), pViaSSurface->yStride >> 1,
+		uOffs(pViaSurface), pViaSurface->yStride >> 1,
+		width >> 1, height >> 1, 1, 1, VIABLIT_COPY, 0);
+	flushPCIXvMCLowLevel(&pViaXvMC->xl);
+	viaBlit(&pViaXvMC->xl, 8, vOffs(pViaSSurface), pViaSSurface->yStride >> 1,
+		vOffs(pViaSurface), pViaSurface->yStride >> 1,
+		width >> 1, height >> 1, 1, 1, VIABLIT_COPY, 0);
+    } else {
+	
+	/*
+	 * NV12 Chroma blit.
+	 */
+
+	viaBlit(&pViaXvMC->xl, 8, vOffs(pViaSSurface), pViaSSurface->yStride,
+		vOffs(pViaSurface), pViaSurface->yStride,
+		width, height >> 1, 1, 1, VIABLIT_COPY, 0);
+    }
     pViaSurface->needsSync = 1;
     pViaSurface->syncMode = LL_MODE_2D;
     pViaSurface->timeStamp = viaDMATimeStampLowLevel(&pViaXvMC->xl);
@@ -1692,6 +1741,7 @@
 	hwlUnlock(&pViaXvMC->xl,0);
     }
     pthread_mutex_unlock( &pViaXvMC->ctxMutex );
+    sched_yield();
     return ret;
 }
 
diff -Naur libxvmc-20050514-old/viaXvMCPriv.h libxvmc-20050514-new/viaXvMCPriv.h
--- libxvmc-20050514-old/viaXvMCPriv.h	2005-03-12 08:29:43.000000000 -0800
+++ libxvmc-20050514-new/viaXvMCPriv.h	2005-05-15 10:24:02.418294192 -0700
@@ -29,6 +29,7 @@
 #include <XvMC.h>
 #include <XvMClib.h>
 #include <stdlib.h>
+#include <Xutil.h>
 #include "vldXvMC.h"
 #include "via_xvmc.h"
 #include "viaLowLevel.h"
@@ -56,17 +57,28 @@
 				     query*/
 
 typedef enum{
+  context_drawHash,
   context_lowLevel,
   context_mutex,
   context_sAreaMap,
   context_fbMap,
   context_mmioMap,
-  context_context,
+  context_drmContext,
   context_fd,
+  context_driConnection,
+  context_context,
   context_none
 } ContextRes;
 
 typedef struct{
+    int x;
+    int y;
+    int w;
+    int h;
+} XvMCRegion;
+
+
+typedef struct{
     unsigned ctxNo;                 /* XvMC private context reference number */
     pthread_mutex_t ctxMutex;       /* Mutex for multi-threading. Not used */
     drm_context_t drmcontext;       /* The drm context */
@@ -119,6 +131,15 @@
     int lastSrfDisplaying;
     ContextRes resources;
     CARD32 timeStamp;
+    XID id;
+    unsigned screen;
+    unsigned depth;
+    unsigned stride;
+    XVisualInfo visualInfo;
+    void *drawHash;
+    CARD32 chipId;
+    XvMCRegion sRegion;
+    XvMCRegion dRegion;
 }ViaXvMCContext;
 
 typedef struct{
@@ -201,4 +222,5 @@
 #define VIABLIT_COPY 1
 #define VIABLIT_FILL 2
 
+
 #endif
diff -Naur libxvmc-20050514-old/xf86dri.c libxvmc-20050514-new/xf86dri.c
--- libxvmc-20050514-old/xf86dri.c	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/xf86dri.c	2005-05-15 10:24:02.419294079 -0700
@@ -0,0 +1,592 @@
+/* $XFree86: xc/lib/GL/dri/XF86dri.c,v 1.13 2002/10/30 12:51:25 alanh Exp $ */
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+Copyright 2000 VA Linux Systems, Inc.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Kevin E. Martin <martin@valinux.com>
+ *   Jens Owen <jens@tungstengraphics.com>
+ *   Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+/* THIS IS NOT AN X CONSORTIUM STANDARD */
+
+#define NEED_REPLIES
+#include <X11/Xlibint.h>
+#include <X11/extensions/Xext.h>
+#include "extutil.h"
+/* #include "glheader.h" */
+#include "xf86dristr.h"
+
+static XExtensionInfo _xf86dri_info_data;
+static XExtensionInfo *xf86dri_info = &_xf86dri_info_data;
+static char xf86dri_extension_name[] = XF86DRINAME;
+
+#define XF86DRICheckExtension(dpy,i,val) \
+  XextCheckExtension (dpy, i, xf86dri_extension_name, val)
+
+/*****************************************************************************
+ *                                                                           *
+ *			   private utility routines                          *
+ *                                                                           *
+ *****************************************************************************/
+
+static int close_display(Display *dpy, XExtCodes *extCodes);
+static /* const */ XExtensionHooks xf86dri_extension_hooks = {
+    NULL,				/* create_gc */
+    NULL,				/* copy_gc */
+    NULL,				/* flush_gc */
+    NULL,				/* free_gc */
+    NULL,				/* create_font */
+    NULL,				/* free_font */
+    close_display,			/* close_display */
+    NULL,				/* wire_to_event */
+    NULL,				/* event_to_wire */
+    NULL,				/* error */
+    NULL,				/* error_string */
+};
+
+static XEXT_GENERATE_FIND_DISPLAY (find_display, xf86dri_info, 
+				   xf86dri_extension_name, 
+				   &xf86dri_extension_hooks, 
+				   0, NULL)
+
+static XEXT_GENERATE_CLOSE_DISPLAY (close_display, xf86dri_info)
+
+
+/*****************************************************************************
+ *                                                                           *
+ *		    public XFree86-DRI Extension routines                    *
+ *                                                                           *
+ *****************************************************************************/
+
+#if 0
+#include <stdio.h>
+#define TRACE(msg)  fprintf(stderr,"XF86DRI%s\n", msg);
+#else
+#define TRACE(msg)
+#endif
+
+
+ Bool XF86DRIQueryExtension (dpy, event_basep, error_basep)
+    Display *dpy;
+    int *event_basep, *error_basep;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+
+    TRACE("QueryExtension...");
+    if (XextHasExtension(info)) {
+	*event_basep = info->codes->first_event;
+	*error_basep = info->codes->first_error;
+        TRACE("QueryExtension... return True");
+	return True;
+    } else {
+        TRACE("QueryExtension... return False");
+	return False;
+    }
+}
+
+ Bool XF86DRIQueryVersion(dpy, majorVersion, minorVersion, patchVersion)
+    Display* dpy;
+    int* majorVersion; 
+    int* minorVersion;
+    int* patchVersion;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIQueryVersionReply rep;
+    xXF86DRIQueryVersionReq *req;
+
+    TRACE("QueryVersion...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIQueryVersion, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIQueryVersion;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("QueryVersion... return False");
+	return False;
+    }
+    *majorVersion = rep.majorVersion;
+    *minorVersion = rep.minorVersion;
+    *patchVersion = rep.patchVersion;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("QueryVersion... return True");
+    return True;
+}
+
+ Bool XF86DRIQueryDirectRenderingCapable(dpy, screen, isCapable)
+    Display* dpy;
+    int screen;
+    Bool* isCapable;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIQueryDirectRenderingCapableReply rep;
+    xXF86DRIQueryDirectRenderingCapableReq *req;
+
+    TRACE("QueryDirectRenderingCapable...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIQueryDirectRenderingCapable, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIQueryDirectRenderingCapable;
+    req->screen = screen;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("QueryDirectRenderingCapable... return False");
+	return False;
+    }
+    *isCapable = rep.isCapable;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("QueryDirectRenderingCapable... return True");
+    return True;
+}
+
+ Bool XF86DRIOpenConnection(dpy, screen, hSAREA, busIdString)
+    Display* dpy;
+    int screen;
+    drm_handle_t * hSAREA;
+    char **busIdString;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIOpenConnectionReply rep;
+    xXF86DRIOpenConnectionReq *req;
+
+    TRACE("OpenConnection...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIOpenConnection, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIOpenConnection;
+    req->screen = screen;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("OpenConnection... return False");
+	return False;
+    }
+
+    *hSAREA = rep.hSAREALow;
+#ifdef LONG64
+    *hSAREA |= ((drm_handle_t)rep.hSAREAHigh) << 32;
+#endif
+
+    if (rep.length) {
+        if (!(*busIdString = (char *)Xcalloc(rep.busIdStringLength + 1, 1))) {
+            _XEatData(dpy, ((rep.busIdStringLength+3) & ~3));
+            UnlockDisplay(dpy);
+            SyncHandle();
+            TRACE("OpenConnection... return False");
+            return False;
+        }
+	_XReadPad(dpy, *busIdString, rep.busIdStringLength);
+    } else {
+        *busIdString = NULL;
+    }
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("OpenConnection... return True");
+    return True;
+}
+
+ Bool XF86DRIAuthConnection(dpy, screen, magic)
+    Display* dpy;
+    int screen;
+    drm_magic_t magic;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIAuthConnectionReq *req;
+    xXF86DRIAuthConnectionReply rep;
+
+    TRACE("AuthConnection...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIAuthConnection, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIAuthConnection;
+    req->screen = screen;
+    req->magic = magic;
+    rep.authenticated = 0;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse) || !rep.authenticated) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("AuthConnection... return False");
+	return False;
+    }
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("AuthConnection... return True");
+    return True;
+}
+
+ Bool XF86DRICloseConnection(dpy, screen)
+    Display* dpy;
+    int screen;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRICloseConnectionReq *req;
+
+    TRACE("CloseConnection...");
+
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRICloseConnection, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRICloseConnection;
+    req->screen = screen;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("CloseConnection... return True");
+    return True;
+}
+
+ Bool XF86DRIGetClientDriverName(dpy, screen, ddxDriverMajorVersion, 
+	ddxDriverMinorVersion, ddxDriverPatchVersion, clientDriverName)
+    Display* dpy;
+    int screen;
+    int* ddxDriverMajorVersion;
+    int* ddxDriverMinorVersion;
+    int* ddxDriverPatchVersion;
+    char** clientDriverName;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIGetClientDriverNameReply rep;
+    xXF86DRIGetClientDriverNameReq *req;
+
+    TRACE("GetClientDriverName...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIGetClientDriverName, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIGetClientDriverName;
+    req->screen = screen;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("GetClientDriverName... return False");
+	return False;
+    }
+
+    *ddxDriverMajorVersion = rep.ddxDriverMajorVersion;
+    *ddxDriverMinorVersion = rep.ddxDriverMinorVersion;
+    *ddxDriverPatchVersion = rep.ddxDriverPatchVersion;
+
+    if (rep.length) {
+        if (!(*clientDriverName = (char *)Xcalloc(rep.clientDriverNameLength + 1, 1))) {
+            _XEatData(dpy, ((rep.clientDriverNameLength+3) & ~3));
+            UnlockDisplay(dpy);
+            SyncHandle();
+            TRACE("GetClientDriverName... return False");
+            return False;
+        }
+	_XReadPad(dpy, *clientDriverName, rep.clientDriverNameLength);
+    } else {
+        *clientDriverName = NULL;
+    }
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("GetClientDriverName... return True");
+    return True;
+}
+
+ Bool XF86DRICreateContextWithConfig(dpy, screen, configID, context,
+	hHWContext)
+    Display* dpy;
+    int screen;
+    int configID;
+    XID* context;
+    drm_context_t * hHWContext;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRICreateContextReply rep;
+    xXF86DRICreateContextReq *req;
+
+    TRACE("CreateContext...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRICreateContext, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRICreateContext;
+    req->visual = configID;
+    req->screen = screen;
+    *context = XAllocID(dpy);
+    req->context = *context;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("CreateContext... return False");
+	return False;
+    }
+    *hHWContext = rep.hHWContext;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("CreateContext... return True");
+    return True;
+}
+
+ Bool XF86DRICreateContext(dpy, screen, visual, context, hHWContext)
+    Display* dpy;
+    int screen;
+    Visual* visual;
+    XID* context;
+    drm_context_t * hHWContext;
+{
+    return XF86DRICreateContextWithConfig( dpy, screen, visual->visualid,
+					   context, hHWContext );
+}
+
+ Bool XF86DRIDestroyContext( Display * ndpy, int screen, 
+    XID context )
+{
+    Display * const dpy = (Display *) ndpy;
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIDestroyContextReq *req;
+
+    TRACE("DestroyContext...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIDestroyContext, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIDestroyContext;
+    req->screen = screen;
+    req->context = context;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("DestroyContext... return True");
+    return True;
+}
+
+Bool XF86DRICreateDrawable( Display * ndpy, int screen, 
+			    Drawable drawable, drm_drawable_t * hHWDrawable )
+{
+    Display * const dpy = (Display *) ndpy;
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRICreateDrawableReply rep;
+    xXF86DRICreateDrawableReq *req;
+
+    TRACE("CreateDrawable...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRICreateDrawable, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRICreateDrawable;
+    req->screen = screen;
+    req->drawable = drawable;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("CreateDrawable... return False");
+	return False;
+    }
+    *hHWDrawable = rep.hHWDrawable;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("CreateDrawable... return True");
+    return True;
+}
+
+Bool XF86DRIDestroyDrawable( Display * ndpy, int screen,
+			     Drawable drawable )
+{
+    Display * const dpy = (Display *) ndpy;
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIDestroyDrawableReq *req;
+
+    TRACE("DestroyDrawable...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIDestroyDrawable, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIDestroyDrawable;
+    req->screen = screen;
+    req->drawable = drawable;
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("DestroyDrawable... return True");
+    return True;
+}
+
+ Bool XF86DRIGetDrawableInfo(Display* dpy, int screen, Drawable drawable,
+    unsigned int* index, unsigned int* stamp,
+    int* X, int* Y, int* W, int* H,
+    int* numClipRects, drm_clip_rect_t ** pClipRects,
+    int* backX, int* backY,
+    int* numBackClipRects, drm_clip_rect_t ** pBackClipRects )
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIGetDrawableInfoReply rep;
+    xXF86DRIGetDrawableInfoReq *req;
+    int total_rects;
+
+    TRACE("GetDrawableInfo...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIGetDrawableInfo, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIGetDrawableInfo;
+    req->screen = screen;
+    req->drawable = drawable;
+
+    if (!_XReply(dpy, (xReply *)&rep, 1, xFalse)) 
+    {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("GetDrawableInfo... return False");
+	return False;
+    }
+    *index = rep.drawableTableIndex;
+    *stamp = rep.drawableTableStamp;
+    *X = (int)rep.drawableX;
+    *Y = (int)rep.drawableY;
+    *W = (int)rep.drawableWidth;
+    *H = (int)rep.drawableHeight;
+    *numClipRects = rep.numClipRects;
+    total_rects = *numClipRects;
+
+    *backX = rep.backX;
+    *backY = rep.backY;
+    *numBackClipRects = rep.numBackClipRects;
+    total_rects += *numBackClipRects;
+
+#if 0
+    /* Because of the fix in Xserver/GL/dri/xf86dri.c, this check breaks
+     * backwards compatibility (Because of the >> 2 shift) but the fix
+     * enables multi-threaded apps to work.
+     */
+    if (rep.length !=  ((((SIZEOF(xXF86DRIGetDrawableInfoReply) - 
+		       SIZEOF(xGenericReply) + 
+		       total_rects * sizeof(drm_clip_rect_t)) + 3) & ~3) >> 2)) {
+        _XEatData(dpy, rep.length);
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("GetDrawableInfo... return False");
+        return False;
+    }
+#endif
+
+    if (*numClipRects) {
+       int len = sizeof(drm_clip_rect_t) * (*numClipRects);
+
+       *pClipRects = (drm_clip_rect_t *)Xcalloc(len, 1);
+       if (*pClipRects) 
+	  _XRead(dpy, (char*)*pClipRects, len);
+    } else {
+        *pClipRects = NULL;
+    }
+
+    if (*numBackClipRects) {
+       int len = sizeof(drm_clip_rect_t) * (*numBackClipRects);
+
+       *pBackClipRects = (drm_clip_rect_t *)Xcalloc(len, 1);
+       if (*pBackClipRects) 
+	  _XRead(dpy, (char*)*pBackClipRects, len);
+    } else {
+        *pBackClipRects = NULL;
+    }
+
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("GetDrawableInfo... return True");
+    return True;
+}
+
+ Bool XF86DRIGetDeviceInfo(dpy, screen, hFrameBuffer, 
+	fbOrigin, fbSize, fbStride, devPrivateSize, pDevPrivate)
+    Display* dpy;
+    int screen;
+    drm_handle_t * hFrameBuffer;
+    int* fbOrigin;
+    int* fbSize;
+    int* fbStride;
+    int* devPrivateSize;
+    void** pDevPrivate;
+{
+    XExtDisplayInfo *info = find_display (dpy);
+    xXF86DRIGetDeviceInfoReply rep;
+    xXF86DRIGetDeviceInfoReq *req;
+
+    TRACE("GetDeviceInfo...");
+    XF86DRICheckExtension (dpy, info, False);
+
+    LockDisplay(dpy);
+    GetReq(XF86DRIGetDeviceInfo, req);
+    req->reqType = info->codes->major_opcode;
+    req->driReqType = X_XF86DRIGetDeviceInfo;
+    req->screen = screen;
+    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+	UnlockDisplay(dpy);
+	SyncHandle();
+        TRACE("GetDeviceInfo... return False");
+	return False;
+    }
+
+    *hFrameBuffer = rep.hFrameBufferLow;
+#ifdef LONG64
+    *hFrameBuffer |= ((drm_handle_t)rep.hFrameBufferHigh) << 32;
+#endif
+
+    *fbOrigin = rep.framebufferOrigin;
+    *fbSize = rep.framebufferSize;
+    *fbStride = rep.framebufferStride;
+    *devPrivateSize = rep.devPrivateSize;
+
+    if (rep.length) {
+        if (!(*pDevPrivate = (void *)Xcalloc(rep.devPrivateSize, 1))) {
+            _XEatData(dpy, ((rep.devPrivateSize+3) & ~3));
+            UnlockDisplay(dpy);
+            SyncHandle();
+            TRACE("GetDeviceInfo... return False");
+            return False;
+        }
+	_XRead(dpy, (char*)*pDevPrivate, rep.devPrivateSize);
+    } else {
+        *pDevPrivate = NULL;
+    }
+
+    UnlockDisplay(dpy);
+    SyncHandle();
+    TRACE("GetDeviceInfo... return True");
+    return True;
+}
+
diff -Naur libxvmc-20050514-old/xf86dri.h libxvmc-20050514-new/xf86dri.h
--- libxvmc-20050514-old/xf86dri.h	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/xf86dri.h	2005-05-15 10:24:02.419294079 -0700
@@ -0,0 +1,121 @@
+/* $XFree86: xc/lib/GL/dri/xf86dri.h,v 1.8 2002/10/30 12:51:25 alanh Exp $ */
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+Copyright 2000 VA Linux Systems, Inc.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/**
+ * \file xf86dri.h
+ * Protocol numbers and function prototypes for DRI X protocol.
+ *
+ * \author Kevin E. Martin <martin@valinux.com>
+ * \author Jens Owen <jens@tungstengraphics.com>
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+
+#ifndef _XF86DRI_H_
+#define _XF86DRI_H_
+
+#include <X11/Xfuncproto.h>
+#include <xf86drm.h>
+
+#define X_XF86DRIQueryVersion			0
+#define X_XF86DRIQueryDirectRenderingCapable	1
+#define X_XF86DRIOpenConnection			2
+#define X_XF86DRICloseConnection		3
+#define X_XF86DRIGetClientDriverName		4
+#define X_XF86DRICreateContext			5
+#define X_XF86DRIDestroyContext			6
+#define X_XF86DRICreateDrawable			7
+#define X_XF86DRIDestroyDrawable		8
+#define X_XF86DRIGetDrawableInfo		9
+#define X_XF86DRIGetDeviceInfo			10
+#define X_XF86DRIAuthConnection                 11
+#define X_XF86DRIOpenFullScreen                 12   /* Deprecated */
+#define X_XF86DRICloseFullScreen                13   /* Deprecated */
+
+#define XF86DRINumberEvents		0
+
+#define XF86DRIClientNotLocal		0
+#define XF86DRIOperationNotSupported	1
+#define XF86DRINumberErrors		(XF86DRIOperationNotSupported + 1)
+
+#ifndef _XF86DRI_SERVER_
+
+
+_XFUNCPROTOBEGIN
+
+Bool XF86DRIQueryExtension( Display *dpy, int *event_base, int *error_base );
+
+Bool XF86DRIQueryVersion( Display *dpy, int *majorVersion, int *minorVersion,
+    int *patchVersion );
+
+Bool XF86DRIQueryDirectRenderingCapable( Display *dpy, int screen,
+    Bool *isCapable );
+
+Bool XF86DRIOpenConnection( Display *dpy, int screen, drm_handle_t *hSAREA,
+    char **busIDString );
+
+Bool XF86DRIAuthConnection( Display *dpy, int screen, drm_magic_t magic );
+
+Bool XF86DRICloseConnection( Display *dpy, int screen );
+
+Bool XF86DRIGetClientDriverName( Display *dpy, int screen,
+    int *ddxDriverMajorVersion, int *ddxDriverMinorVersion,
+    int *ddxDriverPatchVersion, char **clientDriverName );
+
+Bool XF86DRICreateContext( Display *dpy, int screen, Visual *visual,
+    XID *ptr_to_returned_context_id, drm_context_t *hHWContext );
+
+Bool XF86DRICreateContextWithConfig( Display *dpy, int screen, int configID,
+    XID *ptr_to_returned_context_id, drm_context_t *hHWContext );
+
+extern Bool XF86DRIDestroyContext( Display *dpy, int screen,
+    XID context_id );
+
+extern Bool XF86DRICreateDrawable( Display *dpy, int screen,
+    Drawable drawable, drm_drawable_t *hHWDrawable );
+
+extern Bool XF86DRIDestroyDrawable( Display *dpy, int screen, 
+    Drawable drawable);
+
+Bool XF86DRIGetDrawableInfo( Display *dpy, int screen, Drawable drawable,
+    unsigned int *index, unsigned int *stamp, 
+    int *X, int *Y, int *W, int *H,
+    int *numClipRects, drm_clip_rect_t ** pClipRects,
+    int *backX, int *backY,
+    int *numBackClipRects, drm_clip_rect_t **pBackClipRects );
+
+Bool XF86DRIGetDeviceInfo( Display *dpy, int screen,
+    drm_handle_t *hFrameBuffer, int *fbOrigin, int *fbSize,
+    int *fbStride, int *devPrivateSize, void **pDevPrivate );
+
+_XFUNCPROTOEND
+
+#endif /* _XF86DRI_SERVER_ */
+
+#endif /* _XF86DRI_H_ */
+
diff -Naur libxvmc-20050514-old/xf86dristr.h libxvmc-20050514-new/xf86dristr.h
--- libxvmc-20050514-old/xf86dristr.h	1969-12-31 16:00:00.000000000 -0800
+++ libxvmc-20050514-new/xf86dristr.h	2005-05-15 10:24:02.420293967 -0700
@@ -0,0 +1,343 @@
+/* $XFree86: xc/lib/GL/dri/xf86dristr.h,v 1.10 2002/10/30 12:51:25 alanh Exp $ */
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+Copyright 2000 VA Linux Systems, Inc.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Kevin E. Martin <martin@valinux.com>
+ *   Jens Owen <jens@tungstengraphics.com>
+ *   Rickard E. (Rik) Fiath <faith@valinux.com>
+ *
+ */
+
+#ifndef _XF86DRISTR_H_
+#define _XF86DRISTR_H_
+
+#include "xf86dri.h"
+
+#define XF86DRINAME "XFree86-DRI"
+
+/* The DRI version number.  This was originally set to be the same of the
+ * XFree86 version number.  However, this version is really indepedent of
+ * the XFree86 version.
+ *
+ * Version History:
+ *    4.0.0: Original
+ *    4.0.1: Patch to bump clipstamp when windows are destroyed, 28 May 02
+ *    4.1.0: Add transition from single to multi in DRMInfo rec, 24 Jun 02
+ */
+#define XF86DRI_MAJOR_VERSION	4
+#define XF86DRI_MINOR_VERSION	1
+#define XF86DRI_PATCH_VERSION	0
+
+typedef struct _XF86DRIQueryVersion {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIQueryVersion */
+    CARD16	length B16;
+} xXF86DRIQueryVersionReq;
+#define sz_xXF86DRIQueryVersionReq	4
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD16	majorVersion B16;	/* major version of DRI protocol */
+    CARD16	minorVersion B16;	/* minor version of DRI protocol */
+    CARD32	patchVersion B32;       /* patch version of DRI protocol */
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xXF86DRIQueryVersionReply;
+#define sz_xXF86DRIQueryVersionReply	32
+
+typedef struct _XF86DRIQueryDirectRenderingCapable {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* X_DRIQueryDirectRenderingCapable */
+    CARD16	length B16;
+    CARD32	screen B32;
+} xXF86DRIQueryDirectRenderingCapableReq;
+#define sz_xXF86DRIQueryDirectRenderingCapableReq	8
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    BOOL	isCapable;
+    BOOL	pad2;
+    BOOL	pad3;
+    BOOL	pad4;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+    CARD32	pad7 B32;
+    CARD32	pad8 B32;
+    CARD32	pad9 B32;
+} xXF86DRIQueryDirectRenderingCapableReply;
+#define sz_xXF86DRIQueryDirectRenderingCapableReply	32
+
+typedef struct _XF86DRIOpenConnection {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIOpenConnection */
+    CARD16	length B16;
+    CARD32	screen B32;
+} xXF86DRIOpenConnectionReq;
+#define sz_xXF86DRIOpenConnectionReq	8
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	hSAREALow B32;
+    CARD32	hSAREAHigh B32;
+    CARD32	busIdStringLength B32;
+    CARD32	pad6 B32;
+    CARD32	pad7 B32;
+    CARD32	pad8 B32;
+} xXF86DRIOpenConnectionReply;
+#define sz_xXF86DRIOpenConnectionReply	32
+
+typedef struct _XF86DRIAuthConnection {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRICloseConnection */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32      magic B32;
+} xXF86DRIAuthConnectionReq;
+#define sz_xXF86DRIAuthConnectionReq	12
+
+typedef struct {
+    BYTE        type;
+    BOOL        pad1;
+    CARD16      sequenceNumber B16;
+    CARD32      length B32;
+    CARD32      authenticated B32;
+    CARD32      pad2 B32;
+    CARD32      pad3 B32;
+    CARD32      pad4 B32;
+    CARD32      pad5 B32;
+    CARD32      pad6 B32;
+} xXF86DRIAuthConnectionReply;
+#define zx_xXF86DRIAuthConnectionReply  32
+
+typedef struct _XF86DRICloseConnection {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRICloseConnection */
+    CARD16	length B16;
+    CARD32	screen B32;
+} xXF86DRICloseConnectionReq;
+#define sz_xXF86DRICloseConnectionReq	8
+
+typedef struct _XF86DRIGetClientDriverName {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIGetClientDriverName */
+    CARD16	length B16;
+    CARD32	screen B32;
+} xXF86DRIGetClientDriverNameReq;
+#define sz_xXF86DRIGetClientDriverNameReq	8
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	ddxDriverMajorVersion B32;
+    CARD32	ddxDriverMinorVersion B32;
+    CARD32	ddxDriverPatchVersion B32;
+    CARD32	clientDriverNameLength B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xXF86DRIGetClientDriverNameReply;
+#define sz_xXF86DRIGetClientDriverNameReply	32
+
+typedef struct _XF86DRICreateContext {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRICreateContext */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32	visual B32;
+    CARD32	context B32;
+} xXF86DRICreateContextReq;
+#define sz_xXF86DRICreateContextReq	16
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	hHWContext B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xXF86DRICreateContextReply;
+#define sz_xXF86DRICreateContextReply	32
+
+typedef struct _XF86DRIDestroyContext {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIDestroyContext */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32	context B32;
+} xXF86DRIDestroyContextReq;
+#define sz_xXF86DRIDestroyContextReq	12
+
+typedef struct _XF86DRICreateDrawable {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRICreateDrawable */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32	drawable B32;
+} xXF86DRICreateDrawableReq;
+#define sz_xXF86DRICreateDrawableReq	12
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	hHWDrawable B32;
+    CARD32	pad2 B32;
+    CARD32	pad3 B32;
+    CARD32	pad4 B32;
+    CARD32	pad5 B32;
+    CARD32	pad6 B32;
+} xXF86DRICreateDrawableReply;
+#define sz_xXF86DRICreateDrawableReply	32
+
+typedef struct _XF86DRIDestroyDrawable {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIDestroyDrawable */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32	drawable B32;
+} xXF86DRIDestroyDrawableReq;
+#define sz_xXF86DRIDestroyDrawableReq	12
+
+typedef struct _XF86DRIGetDrawableInfo {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIGetDrawableInfo */
+    CARD16	length B16;
+    CARD32	screen B32;
+    CARD32	drawable B32;
+} xXF86DRIGetDrawableInfoReq;
+#define sz_xXF86DRIGetDrawableInfoReq	12
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	drawableTableIndex B32;
+    CARD32	drawableTableStamp B32;
+    INT16	drawableX B16;
+    INT16	drawableY B16;
+    INT16	drawableWidth B16;
+    INT16	drawableHeight B16;
+    CARD32	numClipRects B32;
+    INT16       backX B16;
+    INT16       backY B16;
+    CARD32      numBackClipRects B32;
+} xXF86DRIGetDrawableInfoReply;
+
+#define sz_xXF86DRIGetDrawableInfoReply	36
+
+
+typedef struct _XF86DRIGetDeviceInfo {
+    CARD8	reqType;		/* always DRIReqCode */
+    CARD8	driReqType;		/* always X_DRIGetDeviceInfo */
+    CARD16	length B16;
+    CARD32	screen B32;
+} xXF86DRIGetDeviceInfoReq;
+#define sz_xXF86DRIGetDeviceInfoReq	8
+
+typedef struct {
+    BYTE	type;			/* X_Reply */
+    BOOL	pad1;
+    CARD16	sequenceNumber B16;
+    CARD32	length B32;
+    CARD32	hFrameBufferLow B32;
+    CARD32	hFrameBufferHigh B32;
+    CARD32	framebufferOrigin B32;
+    CARD32	framebufferSize B32;
+    CARD32	framebufferStride B32;
+    CARD32	devPrivateSize B32;
+} xXF86DRIGetDeviceInfoReply;
+#define sz_xXF86DRIGetDeviceInfoReply	32
+
+typedef struct _XF86DRIOpenFullScreen {
+    CARD8       reqType;	/* always DRIReqCode */
+    CARD8       driReqType;	/* always X_DRIOpenFullScreen */
+    CARD16      length B16;
+    CARD32      screen B32;
+    CARD32      drawable B32;
+} xXF86DRIOpenFullScreenReq;
+#define sz_xXF86DRIOpenFullScreenReq    12
+
+typedef struct {
+    BYTE        type;
+    BOOL        pad1;
+    CARD16      sequenceNumber B16;
+    CARD32      length B32;
+    CARD32      isFullScreen B32;
+    CARD32      pad2 B32;
+    CARD32      pad3 B32;
+    CARD32      pad4 B32;
+    CARD32      pad5 B32;
+    CARD32      pad6 B32;
+} xXF86DRIOpenFullScreenReply;
+#define sz_xXF86DRIOpenFullScreenReply  32
+
+typedef struct _XF86DRICloseFullScreen {
+    CARD8       reqType;	/* always DRIReqCode */
+    CARD8       driReqType;	/* always X_DRICloseFullScreen */
+    CARD16      length B16;
+    CARD32      screen B32;
+    CARD32      drawable B32;
+} xXF86DRICloseFullScreenReq;
+#define sz_xXF86DRICloseFullScreenReq   12
+
+typedef struct {
+    BYTE        type;
+    BOOL        pad1;
+    CARD16      sequenceNumber B16;
+    CARD32      length B32;
+    CARD32      pad2 B32;
+    CARD32      pad3 B32;
+    CARD32      pad4 B32;
+    CARD32      pad5 B32;
+    CARD32      pad6 B32;
+    CARD32      pad7 B32;
+} xXF86DRICloseFullScreenReply;
+#define sz_xXF86DRICloseFullScreenReply  32
+
+
+#endif /* _XF86DRISTR_H_ */
